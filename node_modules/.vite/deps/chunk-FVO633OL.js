import {
  LayerAction,
  createGravityFromModel,
  createSourceFromModel
} from "./chunk-E4M4BZBC.js";
import {
  createGravityModel
} from "./chunk-LI44QUJM.js";
import {
  DeliveryFormatAction,
  toFloatAsString
} from "./chunk-LE6AA2PB.js";
import {
  ACTION_TYPE_TO_CROP_MODE_MAP,
  ACTION_TYPE_TO_EFFECT_MODE_MAP,
  ACTION_TYPE_TO_STREAMING_PROFILE_MODE_MAP,
  CONDITIONAL_OPERATORS,
  CROP_MODE_TO_ACTION_TYPE_MAP,
  EFFECT_MODE_TO_ACTION_TYPE_MAP,
  RESERVED_NAMES,
  STREAMING_PROFILE_TO_ACTION_TYPE_MAP
} from "./chunk-DOI2HF4F.js";
import {
  animated,
  animatedWebP,
  clip,
  clipEvenOdd,
  ignoreInitialAspectRatio,
  regionRelative,
  relative
} from "./chunk-M5SY7NK2.js";
import {
  VideoSource,
  base64Encode,
  prepareColor
} from "./chunk-B43TY7UJ.js";
import {
  Action,
  FlagQualifier
} from "./chunk-4UABOL5W.js";
import {
  GravityQualifier
} from "./chunk-LFEWX2TB.js";
import {
  Qualifier
} from "./chunk-UHKTWXPV.js";
import {
  QualifierValue
} from "./chunk-QESUYXYX.js";
import {
  createUnsupportedError
} from "./chunk-EVDDVMJB.js";

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/aspectRatio/AspectRatioQualifierValue.js
var AspectRatioQualifierValue = class extends QualifierValue {
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeSimpleAction.js
var ResizeSimpleAction = class extends Action {
  /**
   * @param {string} cropType
   * @param {number | string} cropWidth The required width of a transformed asset.
   * @param {number | string} cropHeight The required height of a transformed asset.
   */
  constructor(cropType, cropWidth, cropHeight) {
    super();
    this._actionModel = { dimensions: {} };
    this._actionModel.actionType = CROP_MODE_TO_ACTION_TYPE_MAP[cropType] || cropType;
    this.addQualifier(new Qualifier("c", cropType));
    cropWidth && this.width(cropWidth);
    cropHeight && this.height(cropHeight);
  }
  /**
   * @description Sets the height of the resize
   * @param {string | number} x The height in pixels (if an integer is specified) or as a percentage (if a float is specified).
   */
  height(x) {
    this._actionModel.dimensions.height = x;
    return this.addQualifier(new Qualifier("h", x));
  }
  /**
   * @description Sets the width of the resize
   * @param {string | number} x The width in pixels (if an integer is specified) or as a percentage (if a float is specified).
   */
  width(x) {
    this._actionModel.dimensions.width = x;
    return this.addQualifier(new Qualifier("w", x));
  }
  /**
   * @description Sets the aspect ratio of the asset.
   * For a list of supported types see {@link Qualifiers.AspectRatio|
    * AspectRatio values}
   * @param {AspectRatioType|number|string} ratio The new aspect ratio, specified as a percentage or ratio.
   * @return {this}
   */
  aspectRatio(ratio) {
    if (ratio instanceof AspectRatioQualifierValue) {
      this._actionModel.dimensions.aspectRatio = `${ratio}`;
      return this.addQualifier(new Qualifier("ar", ratio));
    }
    if (typeof ratio === "number" || typeof ratio === "string") {
      this._actionModel.dimensions.aspectRatio = toFloatAsString(ratio);
      return this.addQualifier(new Qualifier("ar", toFloatAsString(ratio)));
    }
    if (ratio instanceof FlagQualifier) {
      this._actionModel.dimensions.aspectRatio = `${ratio.qualifierValue}`;
      return this.addFlag(ratio);
    }
  }
  /**
   * @description Modifies percentage-based width & height parameters of overlays and underlays (e.g., 1.0) to be relative to the containing image instead of the added layer.
   * @return {this}
   */
  relative() {
    this._actionModel.relative = true;
    return this.addFlag(relative());
  }
  /**
   * @description Modifies percentage-based width & height parameters of overlays and underlays (e.g., 1.0) to be relative to the overlaid region
   * @return {this}
   */
  regionRelative() {
    this._actionModel.regionRelative = true;
    return this.addFlag(regionRelative());
  }
  static fromJson(actionModel) {
    const { actionType, dimensions, relative: relative2, regionRelative: regionRelative2 } = actionModel;
    const { aspectRatio, width, height } = dimensions;
    const cropMode = ACTION_TYPE_TO_CROP_MODE_MAP[actionType] || actionType;
    const result = new this(cropMode, width, height);
    aspectRatio && result.aspectRatio(aspectRatio === "ignore_aspect_ratio" ? ignoreInitialAspectRatio() : aspectRatio);
    relative2 && result.relative();
    regionRelative2 && result.regionRelative();
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeAdvancedAction.js
var ResizeAdvancedAction = class extends ResizeSimpleAction {
  /**
   * @description Which part of the original image to include.
   * @param {Qualifiers.Gravity} gravity
   */
  gravity(gravity) {
    this._actionModel.gravity = createGravityModel(gravity);
    const gravityQualifier = typeof gravity === "string" ? new Qualifier("g", gravity) : gravity;
    return this.addQualifier(gravityQualifier);
  }
  static fromJson(actionModel) {
    const result = super.fromJson.apply(this, [actionModel]);
    if (actionModel.gravity) {
      result.gravity(createGravityFromModel(actionModel.gravity));
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/base/BackgroundQualifier.js
var BackgroundQualifier = class extends Qualifier {
  constructor(backgroundValue) {
    super("b");
    if (backgroundValue) {
      this.addValue(backgroundValue);
    }
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/BlurredBackgroundAction.js
var BlurredBackgroundAction = class extends BackgroundQualifier {
  /**
   * @description Sets the intensity of the blur.
   * @param {number} value - The intensity of the blur.
   */
  intensity(value) {
    this.intensityLevel = value;
    return this;
  }
  /**
   * @description Sets the brightness of the background.
   * @param {number} value - The brightness of the background.
   */
  brightness(value) {
    this.brightnessLevel = value;
    return this;
  }
  /**
   * @description
   * Stringify the qualifier
   * BackgroundQualifiers don't have a value, but instead override the toString() function
   */
  toString() {
    return `
    b_blurred
    ${this.intensityLevel ? `:${this.intensityLevel}` : ""}
    ${this.brightnessLevel ? `:${this.brightnessLevel}` : ""}
    `.replace(/\s+/g, "");
  }
};
var BlurredBackgroundAction_default = BlurredBackgroundAction;

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/base/BaseCommonBackground.js
var BaseCommonBackground = class extends BackgroundQualifier {
  constructor() {
    super();
    this._palette = [];
  }
  /**
   * @description Selects the strongest contrasting color to use for padding.
   * @return {this}
   */
  contrast() {
    this._contrast = true;
    return this;
  }
  /**
   * @description Defines the custom colors to use when resizing using content-aware padding.
   * @param {...string} colors One or more colors - Example: palette('green', 'red', blue')
   * @return {this}
   */
  palette(...colors) {
    this._palette = colors.map((color2) => {
      return prepareColor(color2);
    });
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/auto/BackgroundAutoBorderQualifier.js
var BackgroundAutoBorderQualifier = class extends BaseCommonBackground {
  /**
   * @description
   * Stringify the qualifier
   * BackgroundQualifiers don't have a value, but instead override the toString() function.
   */
  toString() {
    return `
    b_auto:border
    ${this._contrast ? "_contrast" : ""}
    ${this._palette.length ? `:palette_${this._palette.join("_")}` : ""}
    `.replace(/\s+/g, "");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/base/BaseGradientBackground.js
var BaseGradientBackground = class extends BaseCommonBackground {
  /**
   *
   * @description Sets the number of predominant colors to use (2 or 4).
   * @param {number} num
   * @return {this}
   */
  gradientColors(num) {
    this._gradientColors = num;
    return this;
  }
  /**
   * @description Sets the direction for a background gradient fade effect.
   * @param {Qualifiers.GradientDirection | GradientDirectionType | string} direction Use one of these functions
   * provided by {@link Qualifiers.GradientDirection|GradientDirection}
   * @return {this}
   */
  gradientDirection(direction) {
    this._gradientDirection = direction;
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/gradient/BackgroundBorderGradientQualifier.js
var BackgroundBorderGradientQualifier = class extends BaseGradientBackground {
  /**
   * @description
   * Stringify the qualifier
   * BackgroundQualifiers don't have a value, but instead override the toString() function.
   */
  toString() {
    return `
    b_auto:border_gradient
    ${this._contrast ? "_contrast" : ""}
    ${this._gradientColors ? `:${this._gradientColors}` : ""}
    ${this._gradientDirection ? `:${this._gradientDirection}` : ""}
    ${this._palette.length ? `:palette_${this._palette.join("_")}` : ""}
    `.replace(/\s+/g, "");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/gradient/BackgroundPredominantGradientQualifier.js
var BackgroundPredominantGradientQualifier = class extends BaseGradientBackground {
  /**
   * @description
   * Stringify the qualifier
   * BackgroundQualifiers don't have a value, but instead override the toString() function.
   */
  toString() {
    return `
    b_auto:predominant_gradient
    ${this._contrast ? "_contrast" : ""}
    ${this._gradientColors ? `:${this._gradientColors}` : ""}
    ${this._gradientDirection ? `:${this._gradientDirection}` : ""}
    ${this._palette.length ? `:palette_${this._palette.join("_")}` : ""}
    `.replace(/\s+/g, "");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/auto/BackgroundAutoPredominantQualifier.js
var BackgroundAutoPredominantQualifier = class extends BaseCommonBackground {
  /**
   * @description
   * Stringify the qualifier
   * BackgroundQualifiers don't have a value, but instead override the toString() function.
   */
  toString() {
    return `
    b_auto:predominant
    ${this._contrast ? "_contrast" : ""}
    ${this._palette.length ? `:palette_${this._palette.join("_")}` : ""}
    `.replace(/\s+/g, "");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createBackgroundModel.js
function getBackgroundValue(background) {
  return `${background}`.replace("b_", "");
}
function createAutoBackgroundModel() {
  return { backgroundType: "auto" };
}
function createBlurredBackgroundModel(background) {
  const { intensityLevel, brightnessLevel } = background;
  const result = {
    backgroundType: "blurred"
  };
  if (intensityLevel || intensityLevel === 0) {
    result.intensity = intensityLevel;
  }
  if (brightnessLevel || brightnessLevel === 0) {
    result.brightness = brightnessLevel;
  }
  return result;
}
function createContrastPaletteBackgroundModel(background) {
  const contrast2 = background._contrast;
  const palette = background._palette;
  const result = {
    backgroundType: ""
  };
  if (contrast2) {
    result.contrast = true;
  }
  if (palette) {
    result.palette = palette;
  }
  return result;
}
function createBorderBackgroundModel(background) {
  return Object.assign(Object.assign({}, createContrastPaletteBackgroundModel(background)), { backgroundType: "border" });
}
function createBaseGradientBackgroundModel(background) {
  const gradientColors = background._gradientColors;
  const gradientDirection = `${background._gradientDirection}`;
  const result = createContrastPaletteBackgroundModel(background);
  if (gradientColors) {
    result.gradientColors = gradientColors;
  }
  if (gradientDirection) {
    result.gradientDirection = gradientDirection;
  }
  return result;
}
function createBorderGradientBackgroundModel(background) {
  return Object.assign(Object.assign({}, createBaseGradientBackgroundModel(background)), { backgroundType: "borderGradient" });
}
function createColorBackgroundModel(background) {
  return {
    backgroundType: "color",
    color: getBackgroundValue(background)
  };
}
function createPredominantBackgroundModel(background) {
  return Object.assign(Object.assign({}, createContrastPaletteBackgroundModel(background)), { backgroundType: "predominant" });
}
function createPredominantGradientBackgroundModel(background) {
  return Object.assign(Object.assign({}, createBaseGradientBackgroundModel(background)), { backgroundType: "predominantGradient" });
}
function createBackgroundModel(background) {
  if (getBackgroundValue(background) === "auto") {
    return createAutoBackgroundModel();
  }
  if (background instanceof BlurredBackgroundAction_default) {
    return createBlurredBackgroundModel(background);
  }
  if (background instanceof BackgroundAutoBorderQualifier) {
    return createBorderBackgroundModel(background);
  }
  if (background instanceof BackgroundBorderGradientQualifier) {
    return createBorderGradientBackgroundModel(background);
  }
  if (background instanceof BackgroundAutoPredominantQualifier) {
    return createPredominantBackgroundModel(background);
  }
  if (background instanceof BackgroundPredominantGradientQualifier) {
    return createPredominantGradientBackgroundModel(background);
  }
  return createColorBackgroundModel(background);
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/textAlignment.js
function left() {
  return "left";
}
function right() {
  return "right";
}
function center() {
  return "center";
}
function start() {
  return "start";
}
function end() {
  return "end";
}
function justify() {
  return "justify";
}
var TextAlignment = { left, right, center, end, justify, start };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/streamingProfile.js
function fullHd() {
  return "full_hd";
}
function hd() {
  return "hd";
}
function sd() {
  return "sd";
}
function fullHdWifi() {
  return "full_hd_wifi";
}
function fullHdLean() {
  return "full_hd_lean";
}
function hdLean() {
  return "hd_lean";
}
var StreamingProfile = {
  hd,
  sd,
  hdLean,
  fullHd,
  fullHdLean,
  fullHdWifi
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/simulateColorBlind.js
function deuteranopia() {
  return "deuteranopia";
}
function protanopia() {
  return "protanopia";
}
function tritanopia() {
  return "tritanopia";
}
function tritanomaly() {
  return "tritanomaly";
}
function deuteranomaly() {
  return "deuteranomaly";
}
function coneMonochromacy() {
  return "cone_monochromacy";
}
function rodMonochromacy() {
  return "rod_monochromacy";
}
var SimulateColorBlind = {
  coneMonochromacy,
  deuteranomaly,
  deuteranopia,
  protanopia,
  rodMonochromacy,
  tritanomaly,
  tritanopia
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/rotate/RotationModeQualifierValue.js
var RotationModeQualifierValue = class extends QualifierValue {
  constructor(val) {
    super();
    this.val = val;
  }
  toString() {
    return this.val;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/rotationMode.js
function autoRight() {
  return new RotationModeQualifierValue("auto_right");
}
function autoLeft() {
  return new RotationModeQualifierValue("auto_left");
}
function verticalFlip() {
  return new RotationModeQualifierValue("vflip");
}
function horizontalFlip() {
  return new RotationModeQualifierValue("hflip");
}
function ignore() {
  return new RotationModeQualifierValue("ignore");
}
var RotationMode = { autoLeft, autoRight, horizontalFlip, ignore, verticalFlip };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/region/NamedRegion.js
var NamedRegion = class extends Action {
  constructor(type) {
    super();
    this.regionType = type;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/region/CustomRegion.js
var CustomRegion = class extends NamedRegion {
  constructor() {
    super("named");
  }
  /**
   * @description The x position in pixels.
   * @param {number} x
   */
  x(x) {
    this.addQualifier(new Qualifier("x", x));
    return this;
  }
  /**
   * @description The y position in pixels.
   * @param {number} y
   */
  y(y) {
    this.addQualifier(new Qualifier("y", y));
    return this;
  }
  /**
   * @description The width of the region in pixels.
   * @param {number} width
   */
  width(width) {
    this.addQualifier(new Qualifier("w", width));
    return this;
  }
  /**
   * @description The height of the region in pixels.
   * @param {number} height
   */
  height(height) {
    this.addQualifier(new Qualifier("h", height));
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/region.js
function custom() {
  return new CustomRegion();
}
function faces() {
  return new NamedRegion("faces");
}
function ocr() {
  return new NamedRegion("ocr_text");
}
var Region = { ocr, faces, custom };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/outlineMode.js
function fill() {
  return "fill";
}
function inner() {
  return "inner";
}
function innerFill() {
  return "inner_fill";
}
function outer() {
  return "outer";
}
var OutlineMode = {
  outer,
  inner,
  innerFill,
  fill
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/improveMode.js
function outdoor() {
  return "outdoor";
}
function indoor() {
  return "indoor";
}
var ImproveMode = {
  indoor,
  outdoor
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/gradientDirection/GradientDirectionQualifierValue.js
var GradientDirectionQualifierValue = class extends QualifierValue {
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/gradientDirection.js
function horizontal() {
  return new GradientDirectionQualifierValue("horizontal");
}
function vertical() {
  return new GradientDirectionQualifierValue("vertical");
}
function diagonalDesc() {
  return new GradientDirectionQualifierValue("diagonal_desc");
}
function diagonalAsc() {
  return new GradientDirectionQualifierValue("diagonal_asc");
}
var GradientDirection = {
  horizontal,
  vertical,
  diagonalDesc,
  diagonalAsc
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/fontHinting.js
function none() {
  return "";
}
function slight() {
  return "slight";
}
function medium() {
  return "medium";
}
function full() {
  return "full";
}
var FontHinting = { full, none, medium, slight };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/expression/ExpressionQualifier.js
var ExpressionQualifier = class extends QualifierValue {
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    return this.value;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/expression.js
function expression(exp) {
  const reservedOperatorList = Object.keys(CONDITIONAL_OPERATORS).map((key) => {
    return `\\s${key.replace(/(\*|\+|\^|\|)/g, "\\$1")}\\s`;
  });
  const regexSafeOperatorList = reservedOperatorList.join("|");
  const operatorsReplaceRE = new RegExp(`(${regexSafeOperatorList})`, "g");
  const stringWithOperators = exp.toString().replace(operatorsReplaceRE, (match) => {
    return `_${CONDITIONAL_OPERATORS[match.trim()]}_`;
  });
  const ReservedNames = Object.keys(RESERVED_NAMES);
  const regexSafeReservedNameList = ReservedNames.join("|");
  const reservedNamesRE = new RegExp(`(\\$_*[^_ ]+)|${regexSafeReservedNameList}`, "g");
  const stringWithVariables = stringWithOperators.replace(reservedNamesRE, (match) => {
    if (match.startsWith("$")) {
      return match;
    } else {
      return RESERVED_NAMES[match] || match;
    }
  });
  const finalExpressionString = stringWithVariables.replace(/\s/g, "_");
  return new ExpressionQualifier(finalExpressionString);
}
var Expression = {
  expression
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/dither.js
function threshold1x1Nondither() {
  return 0;
}
function checkerboard2x1Dither() {
  return 1;
}
function ordered2x2Dispersed() {
  return 2;
}
function ordered3x3Dispersed() {
  return 3;
}
function ordered4x4Dispersed() {
  return 4;
}
function ordered8x8Dispersed() {
  return 5;
}
function halftone4x4Angled() {
  return 6;
}
function halftone6x6Angled() {
  return 7;
}
function halftone8x8Angled() {
  return 8;
}
function halftone4x4Orthogonal() {
  return 9;
}
function halftone6x6Orthogonal() {
  return 10;
}
function halftone8x8Orthogonal() {
  return 11;
}
function halftone16x16Orthogonal() {
  return 12;
}
function circles5x5Black() {
  return 13;
}
function circles5x5White() {
  return 14;
}
function circles6x6Black() {
  return 15;
}
function circles6x6White() {
  return 16;
}
function circles7x7Black() {
  return 17;
}
function circles7x7White() {
  return 18;
}
var Dither = {
  checkerboard2x1Dither,
  circles5x5Black,
  circles5x5White,
  circles6x6Black,
  circles6x6White,
  circles7x7Black,
  circles7x7White,
  halftone4x4Angled,
  halftone4x4Orthogonal,
  halftone6x6Angled,
  halftone6x6Orthogonal,
  halftone8x8Angled,
  halftone8x8Orthogonal,
  halftone16x16Orthogonal,
  ordered2x2Dispersed,
  ordered3x3Dispersed,
  ordered4x4Dispersed,
  ordered8x8Dispersed,
  threshold1x1Nondither
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/color.js
var Color = {
  SNOW: "snow",
  SNOW1: "snow1",
  SNOW2: "snow2",
  ROSYBROWN1: "rosybrown1",
  ROSYBROWN2: "rosybrown2",
  SNOW3: "snow3",
  LIGHTCORAL: "lightcoral",
  INDIANRED1: "indianred1",
  ROSYBROWN3: "rosybrown3",
  INDIANRED2: "indianred2",
  ROSYBROWN: "rosybrown",
  BROWN1: "brown1",
  FIREBRICK1: "firebrick1",
  BROWN2: "brown2",
  INDIANRED: "indianred",
  INDIANRED3: "indianred3",
  FIREBRICK2: "firebrick2",
  SNOW4: "snow4",
  BROWN3: "brown3",
  RED: "red",
  RED1: "red1",
  ROSYBROWN4: "rosybrown4",
  FIREBRICK3: "firebrick3",
  RED2: "red2",
  FIREBRICK: "firebrick",
  BROWN: "brown",
  RED3: "red3",
  INDIANRED4: "indianred4",
  BROWN4: "brown4",
  FIREBRICK4: "firebrick4",
  DARKRED: "darkred",
  RED4: "red4",
  LIGHTPINK1: "lightpink1",
  LIGHTPINK3: "lightpink3",
  LIGHTPINK4: "lightpink4",
  LIGHTPINK2: "lightpink2",
  LIGHTPINK: "lightpink",
  PINK: "pink",
  CRIMSON: "crimson",
  PINK1: "pink1",
  PINK2: "pink2",
  PINK3: "pink3",
  PINK4: "pink4",
  PALEVIOLETRED4: "palevioletred4",
  PALEVIOLETRED: "palevioletred",
  PALEVIOLETRED2: "palevioletred2",
  PALEVIOLETRED1: "palevioletred1",
  PALEVIOLETRED3: "palevioletred3",
  LAVENDERBLUSH: "lavenderblush",
  LAVENDERBLUSH1: "lavenderblush1",
  LAVENDERBLUSH3: "lavenderblush3",
  LAVENDERBLUSH2: "lavenderblush2",
  LAVENDERBLUSH4: "lavenderblush4",
  MAROON: "maroon",
  HOTPINK3: "hotpink3",
  VIOLETRED3: "violetred3",
  VIOLETRED1: "violetred1",
  VIOLETRED2: "violetred2",
  VIOLETRED4: "violetred4",
  HOTPINK2: "hotpink2",
  HOTPINK1: "hotpink1",
  HOTPINK4: "hotpink4",
  HOTPINK: "hotpink",
  DEEPPINK: "deeppink",
  DEEPPINK1: "deeppink1",
  DEEPPINK2: "deeppink2",
  DEEPPINK3: "deeppink3",
  DEEPPINK4: "deeppink4",
  MAROON1: "maroon1",
  MAROON2: "maroon2",
  MAROON3: "maroon3",
  MAROON4: "maroon4",
  MEDIUMVIOLETRED: "mediumvioletred",
  VIOLETRED: "violetred",
  ORCHID2: "orchid2",
  ORCHID: "orchid",
  ORCHID1: "orchid1",
  ORCHID3: "orchid3",
  ORCHID4: "orchid4",
  THISTLE1: "thistle1",
  THISTLE2: "thistle2",
  PLUM1: "plum1",
  PLUM2: "plum2",
  THISTLE: "thistle",
  THISTLE3: "thistle3",
  PLUM: "plum",
  VIOLET: "violet",
  PLUM3: "plum3",
  THISTLE4: "thistle4",
  FUCHSIA: "fuchsia",
  MAGENTA: "magenta",
  MAGENTA1: "magenta1",
  PLUM4: "plum4",
  MAGENTA2: "magenta2",
  MAGENTA3: "magenta3",
  DARKMAGENTA: "darkmagenta",
  MAGENTA4: "magenta4",
  PURPLE: "purple",
  MEDIUMORCHID: "mediumorchid",
  MEDIUMORCHID1: "mediumorchid1",
  MEDIUMORCHID2: "mediumorchid2",
  MEDIUMORCHID3: "mediumorchid3",
  MEDIUMORCHID4: "mediumorchid4",
  DARKVIOLET: "darkviolet",
  DARKORCHID: "darkorchid",
  DARKORCHID1: "darkorchid1",
  DARKORCHID3: "darkorchid3",
  DARKORCHID2: "darkorchid2",
  DARKORCHID4: "darkorchid4",
  INDIGO: "indigo",
  BLUEVIOLET: "blueviolet",
  PURPLE2: "purple2",
  PURPLE3: "purple3",
  PURPLE4: "purple4",
  PURPLE1: "purple1",
  MEDIUMPURPLE: "mediumpurple",
  MEDIUMPURPLE1: "mediumpurple1",
  MEDIUMPURPLE2: "mediumpurple2",
  MEDIUMPURPLE3: "mediumpurple3",
  MEDIUMPURPLE4: "mediumpurple4",
  DARKSLATEBLUE: "darkslateblue",
  LIGHTSLATEBLUE: "lightslateblue",
  MEDIUMSLATEBLUE: "mediumslateblue",
  SLATEBLUE: "slateblue",
  SLATEBLUE1: "slateblue1",
  SLATEBLUE2: "slateblue2",
  SLATEBLUE3: "slateblue3",
  SLATEBLUE4: "slateblue4",
  GHOSTWHITE: "ghostwhite",
  LAVENDER: "lavender",
  BLUE: "blue",
  BLUE1: "blue1",
  BLUE2: "blue2",
  BLUE3: "blue3",
  MEDIUMBLUE: "mediumblue",
  BLUE4: "blue4",
  DARKBLUE: "darkblue",
  MIDNIGHTBLUE: "midnightblue",
  NAVY: "navy",
  NAVYBLUE: "navyblue",
  ROYALBLUE: "royalblue",
  ROYALBLUE1: "royalblue1",
  ROYALBLUE2: "royalblue2",
  ROYALBLUE3: "royalblue3",
  ROYALBLUE4: "royalblue4",
  CORNFLOWERBLUE: "cornflowerblue",
  LIGHTSTEELBLUE: "lightsteelblue",
  LIGHTSTEELBLUE1: "lightsteelblue1",
  LIGHTSTEELBLUE2: "lightsteelblue2",
  LIGHTSTEELBLUE3: "lightsteelblue3",
  LIGHTSTEELBLUE4: "lightsteelblue4",
  SLATEGRAY4: "slategray4",
  SLATEGRAY1: "slategray1",
  SLATEGRAY2: "slategray2",
  SLATEGRAY3: "slategray3",
  LIGHTSLATEGRAY: "lightslategray",
  LIGHTSLATEGREY: "lightslategrey",
  SLATEGRAY: "slategray",
  SLATEGREY: "slategrey",
  DODGERBLUE: "dodgerblue",
  DODGERBLUE1: "dodgerblue1",
  DODGERBLUE2: "dodgerblue2",
  DODGERBLUE4: "dodgerblue4",
  DODGERBLUE3: "dodgerblue3",
  ALICEBLUE: "aliceblue",
  STEELBLUE4: "steelblue4",
  STEELBLUE: "steelblue",
  STEELBLUE1: "steelblue1",
  STEELBLUE2: "steelblue2",
  STEELBLUE3: "steelblue3",
  SKYBLUE4: "skyblue4",
  SKYBLUE1: "skyblue1",
  SKYBLUE2: "skyblue2",
  SKYBLUE3: "skyblue3",
  LIGHTSKYBLUE: "lightskyblue",
  LIGHTSKYBLUE4: "lightskyblue4",
  LIGHTSKYBLUE1: "lightskyblue1",
  LIGHTSKYBLUE2: "lightskyblue2",
  LIGHTSKYBLUE3: "lightskyblue3",
  SKYBLUE: "skyblue",
  LIGHTBLUE3: "lightblue3",
  DEEPSKYBLUE: "deepskyblue",
  DEEPSKYBLUE1: "deepskyblue1",
  DEEPSKYBLUE2: "deepskyblue2",
  DEEPSKYBLUE4: "deepskyblue4",
  DEEPSKYBLUE3: "deepskyblue3",
  LIGHTBLUE1: "lightblue1",
  LIGHTBLUE2: "lightblue2",
  LIGHTBLUE: "lightblue",
  LIGHTBLUE4: "lightblue4",
  POWDERBLUE: "powderblue",
  CADETBLUE1: "cadetblue1",
  CADETBLUE2: "cadetblue2",
  CADETBLUE3: "cadetblue3",
  CADETBLUE4: "cadetblue4",
  TURQUOISE1: "turquoise1",
  TURQUOISE2: "turquoise2",
  TURQUOISE3: "turquoise3",
  TURQUOISE4: "turquoise4",
  CADETBLUE: "cadetblue",
  DARKTURQUOISE: "darkturquoise",
  AZURE: "azure",
  AZURE1: "azure1",
  LIGHTCYAN1: "lightcyan1",
  LIGHTCYAN: "lightcyan",
  AZURE2: "azure2",
  LIGHTCYAN2: "lightcyan2",
  PALETURQUOISE1: "paleturquoise1",
  PALETURQUOISE: "paleturquoise",
  PALETURQUOISE2: "paleturquoise2",
  DARKSLATEGRAY1: "darkslategray1",
  AZURE3: "azure3",
  LIGHTCYAN3: "lightcyan3",
  DARKSLATEGRAY2: "darkslategray2",
  PALETURQUOISE3: "paleturquoise3",
  DARKSLATEGRAY3: "darkslategray3",
  AZURE4: "azure4",
  LIGHTCYAN4: "lightcyan4",
  AQUA: "aqua",
  CYAN: "cyan",
  CYAN1: "cyan1",
  PALETURQUOISE4: "paleturquoise4",
  CYAN2: "cyan2",
  DARKSLATEGRAY4: "darkslategray4",
  CYAN3: "cyan3",
  CYAN4: "cyan4",
  DARKCYAN: "darkcyan",
  TEAL: "teal",
  DARKSLATEGRAY: "darkslategray",
  DARKSLATEGREY: "darkslategrey",
  MEDIUMTURQUOISE: "mediumturquoise",
  LIGHTSEAGREEN: "lightseagreen",
  TURQUOISE: "turquoise",
  AQUAMARINE4: "aquamarine4",
  AQUAMARINE: "aquamarine",
  AQUAMARINE1: "aquamarine1",
  AQUAMARINE2: "aquamarine2",
  AQUAMARINE3: "aquamarine3",
  MEDIUMAQUAMARINE: "mediumaquamarine",
  MEDIUMSPRINGGREEN: "mediumspringgreen",
  MINTCREAM: "mintcream",
  SPRINGGREEN: "springgreen",
  SPRINGGREEN1: "springgreen1",
  SPRINGGREEN2: "springgreen2",
  SPRINGGREEN3: "springgreen3",
  SPRINGGREEN4: "springgreen4",
  MEDIUMSEAGREEN: "mediumseagreen",
  SEAGREEN: "seagreen",
  SEAGREEN3: "seagreen3",
  SEAGREEN1: "seagreen1",
  SEAGREEN4: "seagreen4",
  SEAGREEN2: "seagreen2",
  MEDIUMFORESTGREEN: "mediumforestgreen",
  HONEYDEW: "honeydew",
  HONEYDEW1: "honeydew1",
  HONEYDEW2: "honeydew2",
  DARKSEAGREEN1: "darkseagreen1",
  DARKSEAGREEN2: "darkseagreen2",
  PALEGREEN1: "palegreen1",
  PALEGREEN: "palegreen",
  HONEYDEW3: "honeydew3",
  LIGHTGREEN: "lightgreen",
  PALEGREEN2: "palegreen2",
  DARKSEAGREEN3: "darkseagreen3",
  DARKSEAGREEN: "darkseagreen",
  PALEGREEN3: "palegreen3",
  HONEYDEW4: "honeydew4",
  GREEN1: "green1",
  LIME: "lime",
  LIMEGREEN: "limegreen",
  DARKSEAGREEN4: "darkseagreen4",
  GREEN2: "green2",
  PALEGREEN4: "palegreen4",
  GREEN3: "green3",
  FORESTGREEN: "forestgreen",
  GREEN4: "green4",
  GREEN: "green",
  DARKGREEN: "darkgreen",
  LAWNGREEN: "lawngreen",
  CHARTREUSE: "chartreuse",
  CHARTREUSE1: "chartreuse1",
  CHARTREUSE2: "chartreuse2",
  CHARTREUSE3: "chartreuse3",
  CHARTREUSE4: "chartreuse4",
  GREENYELLOW: "greenyellow",
  DARKOLIVEGREEN3: "darkolivegreen3",
  DARKOLIVEGREEN1: "darkolivegreen1",
  DARKOLIVEGREEN2: "darkolivegreen2",
  DARKOLIVEGREEN4: "darkolivegreen4",
  DARKOLIVEGREEN: "darkolivegreen",
  OLIVEDRAB: "olivedrab",
  OLIVEDRAB1: "olivedrab1",
  OLIVEDRAB2: "olivedrab2",
  OLIVEDRAB3: "olivedrab3",
  YELLOWGREEN: "yellowgreen",
  OLIVEDRAB4: "olivedrab4",
  IVORY: "ivory",
  IVORY1: "ivory1",
  LIGHTYELLOW: "lightyellow",
  LIGHTYELLOW1: "lightyellow1",
  BEIGE: "beige",
  IVORY2: "ivory2",
  LIGHTGOLDENRODYELLOW: "lightgoldenrodyellow",
  LIGHTYELLOW2: "lightyellow2",
  IVORY3: "ivory3",
  LIGHTYELLOW3: "lightyellow3",
  IVORY4: "ivory4",
  LIGHTYELLOW4: "lightyellow4",
  YELLOW: "yellow",
  YELLOW1: "yellow1",
  YELLOW2: "yellow2",
  YELLOW3: "yellow3",
  YELLOW4: "yellow4",
  OLIVE: "olive",
  DARKKHAKI: "darkkhaki",
  KHAKI2: "khaki2",
  LEMONCHIFFON4: "lemonchiffon4",
  KHAKI1: "khaki1",
  KHAKI3: "khaki3",
  KHAKI4: "khaki4",
  PALEGOLDENROD: "palegoldenrod",
  LEMONCHIFFON: "lemonchiffon",
  LEMONCHIFFON1: "lemonchiffon1",
  KHAKI: "khaki",
  LEMONCHIFFON3: "lemonchiffon3",
  LEMONCHIFFON2: "lemonchiffon2",
  MEDIUMGOLDENROD: "mediumgoldenrod",
  CORNSILK4: "cornsilk4",
  GOLD: "gold",
  GOLD1: "gold1",
  GOLD2: "gold2",
  GOLD3: "gold3",
  GOLD4: "gold4",
  LIGHTGOLDENROD: "lightgoldenrod",
  LIGHTGOLDENROD4: "lightgoldenrod4",
  LIGHTGOLDENROD1: "lightgoldenrod1",
  LIGHTGOLDENROD3: "lightgoldenrod3",
  LIGHTGOLDENROD2: "lightgoldenrod2",
  CORNSILK3: "cornsilk3",
  CORNSILK2: "cornsilk2",
  CORNSILK: "cornsilk",
  CORNSILK1: "cornsilk1",
  GOLDENROD: "goldenrod",
  GOLDENROD1: "goldenrod1",
  GOLDENROD2: "goldenrod2",
  GOLDENROD3: "goldenrod3",
  GOLDENROD4: "goldenrod4",
  DARKGOLDENROD: "darkgoldenrod",
  DARKGOLDENROD1: "darkgoldenrod1",
  DARKGOLDENROD2: "darkgoldenrod2",
  DARKGOLDENROD3: "darkgoldenrod3",
  DARKGOLDENROD4: "darkgoldenrod4",
  FLORALWHITE: "floralwhite",
  WHEAT2: "wheat2",
  OLDLACE: "oldlace",
  WHEAT: "wheat",
  WHEAT1: "wheat1",
  WHEAT3: "wheat3",
  ORANGE: "orange",
  ORANGE1: "orange1",
  ORANGE2: "orange2",
  ORANGE3: "orange3",
  ORANGE4: "orange4",
  WHEAT4: "wheat4",
  MOCCASIN: "moccasin",
  PAPAYAWHIP: "papayawhip",
  NAVAJOWHITE3: "navajowhite3",
  BLANCHEDALMOND: "blanchedalmond",
  NAVAJOWHITE: "navajowhite",
  NAVAJOWHITE1: "navajowhite1",
  NAVAJOWHITE2: "navajowhite2",
  NAVAJOWHITE4: "navajowhite4",
  ANTIQUEWHITE4: "antiquewhite4",
  ANTIQUEWHITE: "antiquewhite",
  TAN: "tan",
  BISQUE4: "bisque4",
  BURLYWOOD: "burlywood",
  ANTIQUEWHITE2: "antiquewhite2",
  BURLYWOOD1: "burlywood1",
  BURLYWOOD3: "burlywood3",
  BURLYWOOD2: "burlywood2",
  ANTIQUEWHITE1: "antiquewhite1",
  BURLYWOOD4: "burlywood4",
  ANTIQUEWHITE3: "antiquewhite3",
  DARKORANGE: "darkorange",
  BISQUE2: "bisque2",
  BISQUE: "bisque",
  BISQUE1: "bisque1",
  BISQUE3: "bisque3",
  DARKORANGE1: "darkorange1",
  LINEN: "linen",
  DARKORANGE2: "darkorange2",
  DARKORANGE3: "darkorange3",
  DARKORANGE4: "darkorange4",
  PERU: "peru",
  TAN1: "tan1",
  TAN2: "tan2",
  TAN3: "tan3",
  TAN4: "tan4",
  PEACHPUFF: "peachpuff",
  PEACHPUFF1: "peachpuff1",
  PEACHPUFF4: "peachpuff4",
  PEACHPUFF2: "peachpuff2",
  PEACHPUFF3: "peachpuff3",
  SANDYBROWN: "sandybrown",
  SEASHELL4: "seashell4",
  SEASHELL2: "seashell2",
  SEASHELL3: "seashell3",
  CHOCOLATE: "chocolate",
  CHOCOLATE1: "chocolate1",
  CHOCOLATE2: "chocolate2",
  CHOCOLATE3: "chocolate3",
  CHOCOLATE4: "chocolate4",
  SADDLEBROWN: "saddlebrown",
  SEASHELL: "seashell",
  SEASHELL1: "seashell1",
  SIENNA4: "sienna4",
  SIENNA: "sienna",
  SIENNA1: "sienna1",
  SIENNA2: "sienna2",
  SIENNA3: "sienna3",
  LIGHTSALMON3: "lightsalmon3",
  LIGHTSALMON: "lightsalmon",
  LIGHTSALMON1: "lightsalmon1",
  LIGHTSALMON4: "lightsalmon4",
  LIGHTSALMON2: "lightsalmon2",
  CORAL: "coral",
  ORANGERED: "orangered",
  ORANGERED1: "orangered1",
  ORANGERED2: "orangered2",
  ORANGERED3: "orangered3",
  ORANGERED4: "orangered4",
  DARKSALMON: "darksalmon",
  SALMON1: "salmon1",
  SALMON2: "salmon2",
  SALMON3: "salmon3",
  SALMON4: "salmon4",
  CORAL1: "coral1",
  CORAL2: "coral2",
  CORAL3: "coral3",
  CORAL4: "coral4",
  TOMATO4: "tomato4",
  TOMATO: "tomato",
  TOMATO1: "tomato1",
  TOMATO2: "tomato2",
  TOMATO3: "tomato3",
  MISTYROSE4: "mistyrose4",
  MISTYROSE2: "mistyrose2",
  MISTYROSE: "mistyrose",
  MISTYROSE1: "mistyrose1",
  SALMON: "salmon",
  MISTYROSE3: "mistyrose3",
  WHITE: "white",
  GRAY100: "gray100",
  GREY100: "grey100",
  GRAY99: "gray99",
  GREY99: "grey99",
  GRAY98: "gray98",
  GREY98: "grey98",
  GRAY97: "gray97",
  GREY97: "grey97",
  GRAY96: "gray96",
  GREY96: "grey96",
  WHITESMOKE: "whitesmoke",
  GRAY95: "gray95",
  GREY95: "grey95",
  GRAY94: "gray94",
  GREY94: "grey94",
  GRAY93: "gray93",
  GREY93: "grey93",
  GRAY92: "gray92",
  GREY92: "grey92",
  GRAY91: "gray91",
  GREY91: "grey91",
  GRAY90: "gray90",
  GREY90: "grey90",
  GRAY89: "gray89",
  GREY89: "grey89",
  GRAY88: "gray88",
  GREY88: "grey88",
  GRAY87: "gray87",
  GREY87: "grey87",
  GAINSBORO: "gainsboro",
  GRAY86: "gray86",
  GREY86: "grey86",
  GRAY85: "gray85",
  GREY85: "grey85",
  GRAY84: "gray84",
  GREY84: "grey84",
  GRAY83: "gray83",
  GREY83: "grey83",
  LIGHTGRAY: "lightgray",
  LIGHTGREY: "lightgrey",
  GRAY82: "gray82",
  GREY82: "grey82",
  GRAY81: "gray81",
  GREY81: "grey81",
  GRAY80: "gray80",
  GREY80: "grey80",
  GRAY79: "gray79",
  GREY79: "grey79",
  GRAY78: "gray78",
  GREY78: "grey78",
  GRAY77: "gray77",
  GREY77: "grey77",
  GRAY76: "gray76",
  GREY76: "grey76",
  SILVER: "silver",
  GRAY75: "gray75",
  GREY75: "grey75",
  GRAY74: "gray74",
  GREY74: "grey74",
  GRAY73: "gray73",
  GREY73: "grey73",
  GRAY72: "gray72",
  GREY72: "grey72",
  GRAY71: "gray71",
  GREY71: "grey71",
  GRAY70: "gray70",
  GREY70: "grey70",
  GRAY69: "gray69",
  GREY69: "grey69",
  GRAY68: "gray68",
  GREY68: "grey68",
  GRAY67: "gray67",
  GREY67: "grey67",
  DARKGRAY: "darkgray",
  DARKGREY: "darkgrey",
  GRAY66: "gray66",
  GREY66: "grey66",
  GRAY65: "gray65",
  GREY65: "grey65",
  GRAY64: "gray64",
  GREY64: "grey64",
  GRAY63: "gray63",
  GREY63: "grey63",
  GRAY62: "gray62",
  GREY62: "grey62",
  GRAY61: "gray61",
  GREY61: "grey61",
  GRAY60: "gray60",
  GREY60: "grey60",
  GRAY59: "gray59",
  GREY59: "grey59",
  GRAY58: "gray58",
  GREY58: "grey58",
  GRAY57: "gray57",
  GREY57: "grey57",
  GRAY56: "gray56",
  GREY56: "grey56",
  GRAY55: "gray55",
  GREY55: "grey55",
  GRAY54: "gray54",
  GREY54: "grey54",
  GRAY53: "gray53",
  GREY53: "grey53",
  GRAY52: "gray52",
  GREY52: "grey52",
  GRAY51: "gray51",
  GREY51: "grey51",
  FRACTAL: "fractal",
  GRAY50: "gray50",
  GREY50: "grey50",
  GRAY: "gray",
  GREY: "grey",
  GRAY49: "gray49",
  GREY49: "grey49",
  GRAY48: "gray48",
  GREY48: "grey48",
  GRAY47: "gray47",
  GREY47: "grey47",
  GRAY46: "gray46",
  GREY46: "grey46",
  GRAY45: "gray45",
  GREY45: "grey45",
  GRAY44: "gray44",
  GREY44: "grey44",
  GRAY43: "gray43",
  GREY43: "grey43",
  GRAY42: "gray42",
  GREY42: "grey42",
  DIMGRAY: "dimgray",
  DIMGREY: "dimgrey",
  GRAY41: "gray41",
  GREY41: "grey41",
  GRAY40: "gray40",
  GREY40: "grey40",
  GRAY39: "gray39",
  GREY39: "grey39",
  GRAY38: "gray38",
  GREY38: "grey38",
  GRAY37: "gray37",
  GREY37: "grey37",
  GRAY36: "gray36",
  GREY36: "grey36",
  GRAY35: "gray35",
  GREY35: "grey35",
  GRAY34: "gray34",
  GREY34: "grey34",
  GRAY33: "gray33",
  GREY33: "grey33",
  GRAY32: "gray32",
  GREY32: "grey32",
  GRAY31: "gray31",
  GREY31: "grey31",
  GRAY30: "gray30",
  GREY30: "grey30",
  GRAY29: "gray29",
  GREY29: "grey29",
  GRAY28: "gray28",
  GREY28: "grey28",
  GRAY27: "gray27",
  GREY27: "grey27",
  GRAY26: "gray26",
  GREY26: "grey26",
  GRAY25: "gray25",
  GREY25: "grey25",
  GRAY24: "gray24",
  GREY24: "grey24",
  GRAY23: "gray23",
  GREY23: "grey23",
  GRAY22: "gray22",
  GREY22: "grey22",
  GRAY21: "gray21",
  GREY21: "grey21",
  GRAY20: "gray20",
  GREY20: "grey20",
  GRAY19: "gray19",
  GREY19: "grey19",
  GRAY18: "gray18",
  GREY18: "grey18",
  GRAY17: "gray17",
  GREY17: "grey17",
  GRAY16: "gray16",
  GREY16: "grey16",
  GRAY15: "gray15",
  GREY15: "grey15",
  GRAY14: "gray14",
  GREY14: "grey14",
  GRAY13: "gray13",
  GREY13: "grey13",
  GRAY12: "gray12",
  GREY12: "grey12",
  GRAY11: "gray11",
  GREY11: "grey11",
  GRAY10: "gray10",
  GREY10: "grey10",
  GRAY9: "gray9",
  GREY9: "grey9",
  GRAY8: "gray8",
  GREY8: "grey8",
  GRAY7: "gray7",
  GREY7: "grey7",
  GRAY6: "gray6",
  GREY6: "grey6",
  GRAY5: "gray5",
  GREY5: "grey5",
  GRAY4: "gray4",
  GREY4: "grey4",
  GRAY3: "gray3",
  GREY3: "grey3",
  GRAY2: "gray2",
  GREY2: "grey2",
  GRAY1: "gray1",
  GREY1: "grey1",
  BLACK: "black",
  GRAY0: "gray0",
  GREY0: "grey0",
  OPAQUE: "opaque",
  NONE: "none",
  TRANSPARENT: "transparent"
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background.js
function border() {
  return new BackgroundAutoBorderQualifier();
}
function auto() {
  return new BackgroundQualifier("auto");
}
function borderGradient() {
  return new BackgroundBorderGradientQualifier();
}
function predominantGradient() {
  return new BackgroundPredominantGradientQualifier();
}
function predominant() {
  return new BackgroundAutoPredominantQualifier();
}
function color(colorStr) {
  return new BackgroundQualifier(prepareColor(colorStr));
}
function blurred() {
  return new BlurredBackgroundAction_default();
}
var Background = {
  auto,
  border,
  borderGradient,
  predominantGradient,
  predominant,
  color,
  blurred
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/audioFrequency.js
function ORIGINAL() {
  return "iaf";
}
function FREQ192000() {
  return 192e3;
}
function FREQ176400() {
  return 176400;
}
function FREQ96000() {
  return 96e3;
}
function FREQ88200() {
  return 88200;
}
function FREQ48000() {
  return 48e3;
}
function FREQ8000() {
  return 8e3;
}
function FREQ11025() {
  return 11025;
}
function FREQ16000() {
  return 16e3;
}
function FREQ22050() {
  return 22050;
}
function FREQ32000() {
  return 32e3;
}
function FREQ37800() {
  return 37800;
}
function FREQ44056() {
  return 44056;
}
function FREQ44100() {
  return 44100;
}
function FREQ47250() {
  return 47250;
}
var AudioFrequency = {
  FREQ8000,
  FREQ11025,
  FREQ16000,
  FREQ22050,
  FREQ32000,
  FREQ37800,
  FREQ44056,
  FREQ44100,
  FREQ47250,
  FREQ48000,
  FREQ88200,
  FREQ96000,
  FREQ176400,
  FREQ192000,
  ORIGINAL
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/audioCodec.js
function none2() {
  return "none";
}
function aac() {
  return "aac";
}
function vorbis() {
  return "vorbis";
}
function mp3() {
  return "mp3";
}
function opus() {
  return "opus";
}
var AudioCodec = {
  aac,
  mp3,
  opus,
  none: none2,
  vorbis
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/aspectRatio.js
function ar1X1() {
  return new AspectRatioQualifierValue("1:1");
}
function ar5X4() {
  return new AspectRatioQualifierValue("5:4");
}
function ar4X3() {
  return new AspectRatioQualifierValue("4:3");
}
function ar3X2() {
  return new AspectRatioQualifierValue("3:2");
}
function ar16X9() {
  return new AspectRatioQualifierValue("16:9");
}
function ar3X1() {
  return new AspectRatioQualifierValue("3:1");
}
function ignoreInitialAspectRatio2() {
  return ignoreInitialAspectRatio();
}
var AspectRatio = {
  ar1X1,
  ar5X4,
  ar3X1,
  ar3X2,
  ar4X3,
  ar16X9,
  ignoreInitialAspectRatio: ignoreInitialAspectRatio2
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/artisticFilter.js
function alDente() {
  return "al_dente";
}
function athena() {
  return "athena";
}
function audrey() {
  return "audrey";
}
function aurora() {
  return "aurora";
}
function daguerre() {
  return "daguerre";
}
function eucalyptus() {
  return "eucalyptus";
}
function fes() {
  return "fes";
}
function frost() {
  return "frost";
}
function hairspray() {
  return "hairspray";
}
function hokusai() {
  return "hokusai";
}
function incognito() {
  return "incognito";
}
function linen() {
  return "linen";
}
function peacock() {
  return "peacock";
}
function primavera() {
  return "primavera";
}
function quartz() {
  return "quartz";
}
function redRock() {
  return "red_rock";
}
function refresh() {
  return "refresh";
}
function sizzle() {
  return "sizzle";
}
function sonnet() {
  return "sonnet";
}
function ukulele() {
  return "ukulele";
}
function zorro() {
  return "zorro";
}
var ArtisticFilter = {
  alDente,
  athena,
  audrey,
  aurora,
  daguerre,
  eucalyptus,
  hairspray,
  hokusai,
  peacock,
  primavera,
  quartz,
  incognito,
  redRock,
  sizzle,
  fes,
  linen,
  refresh,
  sonnet,
  ukulele,
  frost,
  zorro
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/animatedFormat/AnimatedFormatQualifierValue.js
var AnimatedFormatQualifierValue = class extends QualifierValue {
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/animatedFormat.js
function auto2() {
  return new AnimatedFormatQualifierValue("auto");
}
function gif() {
  return new AnimatedFormatQualifierValue("gif");
}
function webp() {
  return new AnimatedFormatQualifierValue("webp");
}
function png() {
  return new AnimatedFormatQualifierValue("png");
}
var AnimatedFormat = { auto: auto2, gif, webp, png };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/chromaSubSampling.js
function chroma444() {
  return 444;
}
function chroma420() {
  return 420;
}
var ChromaSubSampling = {
  chroma444,
  chroma420
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/dpr.js
function auto3() {
  return "auto";
}
var Dpr = {
  auto: auto3
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/GradientFade.js
function symmetric() {
  return "symmetric";
}
function symmetricPad() {
  return "symmetric_pad";
}
var GradientFade = {
  symmetric,
  symmetricPad
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createBackgroundFromModel.js
function createBlurredBackground(backgroundModel) {
  const { brightness: brightness2, intensity } = backgroundModel;
  const result = Background.blurred();
  if (brightness2 || brightness2 == 0) {
    result.brightness(brightness2);
  }
  if (intensity || intensity == 0) {
    result.intensity(intensity);
  }
  return result;
}
function createGradientBackground(background, backgroundModel) {
  const { gradientColors, gradientDirection, contrast: contrast2, palette } = backgroundModel;
  if (contrast2) {
    background.contrast();
  }
  if (palette) {
    background.palette(...palette);
  }
  if (gradientColors) {
    background.gradientColors(+gradientColors);
  }
  if (gradientDirection) {
    background.gradientDirection(gradientDirection);
  }
  return background;
}
function createContrastPaletteBackground(background, backgroundModel) {
  const { contrast: contrast2, palette } = backgroundModel;
  if (contrast2) {
    background.contrast();
  }
  if (palette) {
    background.palette(...palette);
  }
  return background;
}
function createBackgroundFromModel(backgroundModel) {
  const { backgroundType } = backgroundModel;
  switch (backgroundType) {
    case "auto":
      return auto();
    case "blurred":
      return createBlurredBackground(backgroundModel);
    case "border":
      return createContrastPaletteBackground(border(), backgroundModel);
    case "borderGradient":
      return createGradientBackground(borderGradient(), backgroundModel);
    case "predominant":
      return createContrastPaletteBackground(predominant(), backgroundModel);
    case "predominantGradient":
      return createGradientBackground(predominantGradient(), backgroundModel);
    default:
      return color(backgroundModel.color);
  }
}

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizePadAction.js
var ResizePadAction = class extends ResizeAdvancedAction {
  /**
   * @description Sets the background.
   * @param {Qualifiers.Background} backgroundQualifier Defines the background color to use instead of
   * transparent background areas or when resizing with padding.
   */
  background(backgroundQualifier) {
    this._actionModel.background = createBackgroundModel(backgroundQualifier);
    return this.addQualifier(backgroundQualifier);
  }
  /**
   * @description Horizontal position for custom-coordinates based padding.
   * @param {number} x The x position.
   */
  offsetX(x) {
    this._actionModel.x = x;
    return this.addQualifier(new Qualifier("x", x));
  }
  /**
   * @description Vertical position for custom-coordinates based padding
   * @param {number} y The y position.
   */
  offsetY(y) {
    this._actionModel.y = y;
    return this.addQualifier(new Qualifier("y", y));
  }
  static fromJson(actionModel) {
    const result = super.fromJson.apply(this, [actionModel]);
    actionModel.background && result.background(createBackgroundFromModel(actionModel.background));
    actionModel.x && result.offsetX(actionModel.x);
    actionModel.y && result.offsetY(actionModel.y);
    actionModel.zoom && result.zoom(actionModel.zoom);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeScaleAction.js
var ResizeScaleAction = class extends ResizeSimpleAction {
  /**
   * @description Changes the aspect ratio of an image while retaining all important content and avoiding unnatural
   * distortions.
   * @return {this}
   */
  liquidRescaling() {
    return this.addQualifier(new GravityQualifier("liquid"));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ThumbnailAction.js
var ThumbResizeAction = class extends ResizeAdvancedAction {
  /**
   * @description Controls how much of the original image surrounding the face to keep when using either the 'crop' or 'thumb' cropping modes with face detection.
   * @param {number | string} z The zoom factor. (Default: 1.0)
   */
  zoom(z) {
    this._actionModel.zoom = z;
    return this.addQualifier(new Qualifier("z", z));
  }
  static fromJson(actionModel) {
    const result = super.fromJson.apply(this, [actionModel]);
    actionModel.zoom && result.zoom(actionModel.zoom);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeCropAction.js
var ResizeCropAction = class extends ResizeAdvancedAction {
  /**
   * @description Horizontal position for custom-coordinates based cropping.
   * @param {number} x The x position.
   */
  x(x) {
    this._actionModel.x = x;
    return this.addQualifier(new Qualifier("x", x));
  }
  /**
   * @description Vertical position for custom-coordinates based cropping
   * @param {number} y The y position.
   */
  y(y) {
    this._actionModel.y = y;
    return this.addQualifier(new Qualifier("y", y));
  }
  /**
   * @description Controls how much of the original image surrounding the face to keep when using either the 'crop' or 'thumb' cropping modes with face detection.
   * @param {number | string} z The zoom factor. (Default: 1.0)
   */
  zoom(z) {
    this._actionModel.zoom = z;
    return this.addQualifier(new Qualifier("z", z));
  }
  static fromJson(actionModel) {
    const result = super.fromJson.apply(this, [actionModel]);
    actionModel.x && result.x(actionModel.x);
    actionModel.y && result.y(actionModel.y);
    actionModel.zoom && result.zoom(actionModel.zoom);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeFillAction.js
var ResizeFillAction = class extends ResizeAdvancedAction {
  /**
   * @description Absolute X position when used with Gravity.xyCenter {@link Qualifiers.Gravity.GravityQualifier}}
   * @param {number} x The x position.
   */
  x(x) {
    this._actionModel.x = x;
    return this.addQualifier(new Qualifier("x", x));
  }
  /**
   * @description Absolute Y position when used with Gravity.xyCenter {@link Qualifiers.Gravity.GravityQualifier}}
   * @param {number} y The y position.
   */
  y(y) {
    this._actionModel.y = y;
    return this.addQualifier(new Qualifier("y", y));
  }
  static fromJson(actionModel) {
    const result = super.fromJson.apply(this, [actionModel]);
    actionModel.x && result.x(actionModel.x);
    actionModel.y && result.y(actionModel.y);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeLimitFitAction.js
var ResizeLimitFitAction = class extends ResizeSimpleAction {
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeLimitFillAction.js
var ResizeLimitFillAction = class extends ResizeFillAction {
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeLimitPadAction.js
var ResizeLimitPadAction = class extends ResizePadAction {
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeMinimumPadAction.js
var ResizeMinimumPadAction = class extends ResizePadAction {
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize.js
function scale(width, height) {
  return new ResizeScaleAction("scale", width, height);
}
function imaggaScale(width, height) {
  return new ResizeSimpleAction("imagga_scale", width, height);
}
function imaggaCrop(width, height) {
  return new ResizeSimpleAction("imagga_crop", width, height);
}
function crop(width, height) {
  return new ResizeCropAction("crop", width, height);
}
function fill2(width, height) {
  return new ResizeFillAction("fill", width, height);
}
function fit(width, height) {
  return new ResizeSimpleAction("fit", width, height);
}
function pad(width, height) {
  return new ResizePadAction("pad", width, height);
}
function limitFill(width, height) {
  return new ResizeLimitFillAction("lfill", width, height);
}
function limitFit(width, height) {
  return new ResizeLimitFitAction("limit", width, height);
}
function minimumPad(width, height) {
  return new ResizeMinimumPadAction("mpad", width, height);
}
function minimumFit(width, height) {
  return new ResizeSimpleAction("mfit", width, height);
}
function fillPad(width, height) {
  return new ResizePadAction("fill_pad", width, height);
}
function thumbnail(width, height) {
  return new ThumbResizeAction("thumb", width, height);
}
function limitPad(width, height) {
  return new ResizeLimitPadAction("lpad", width, height);
}
var Resize = {
  imaggaScale,
  imaggaCrop,
  crop,
  fill: fill2,
  scale,
  minimumPad,
  fit,
  pad,
  limitFit,
  thumbnail,
  limitFill,
  minimumFit,
  limitPad,
  fillPad
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/roundCorners/RoundCornersAction.js
var RoundCornersAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "roundCorners";
  }
  /**
   * @param {number} a
   * @param {number} b
   * @param {number} c
   * @param {number} d
   * @return {RoundCornersAction}
   */
  radius(a, b, c, d) {
    const qualifierValue = new QualifierValue();
    a !== void 0 && qualifierValue.addValue(a);
    b !== void 0 && qualifierValue.addValue(b);
    c !== void 0 && qualifierValue.addValue(c);
    d !== void 0 && qualifierValue.addValue(d);
    const definedRadiuses = [a, b, c, d].filter((r) => r !== void 0);
    this._radius = definedRadiuses;
    this._actionModel.radius = definedRadiuses;
    this.addQualifier(new Qualifier("r").addValue(qualifierValue));
    return this;
  }
  /**
   * @description Applies maximum rounding to the corners of the asset. An asset with square dimensions becomes a circle.
   */
  max() {
    this._radius = "max";
    this._actionModel.radius = "max";
    return this.addQualifier(new Qualifier("r", "max"));
  }
  getRadius() {
    return this._radius;
  }
  static fromJson(actionModel) {
    const { radius } = actionModel;
    const result = new this();
    if (Array.isArray(radius)) {
      result.radius(radius[0], radius[1], radius[2], radius[3]);
    }
    if (radius === "max") {
      result.max();
    }
    return result;
  }
};
var RoundCornersAction_default = RoundCornersAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/border.js
var BorderAction = class extends Action {
  /**
   * @description Adds a border of the specified type around an image or video.
   * @param {'solid'} borderType The type of border (currently only 'solid' is supported). Use values in {@link Qualifiers.Border|Border Values}.
   * @param {string} color The color of the border.
   * @param {number} borderWidth The width in pixels.
   */
  constructor(borderType, color2, borderWidth) {
    super();
    this._actionModel = {};
    this.borderType = borderType;
    this.borderColor = prepareColor(color2);
    this.borderWidth = borderWidth;
    this._actionModel = {
      color: prepareColor(color2),
      width: borderWidth,
      actionType: "border"
    };
  }
  /**
   * @description Sets the width of the border
   * @param {number | string} borderWidth The width in pixels.
   */
  width(borderWidth) {
    this.borderWidth = borderWidth;
    this._actionModel.width = borderWidth;
    return this;
  }
  /**
   * @description Sets the color of the border.
   * @param {string} borderColor The color of the border.
   */
  color(borderColor) {
    this.borderColor = prepareColor(borderColor);
    this._actionModel.color = prepareColor(borderColor);
    return this;
  }
  /**
   * @description Rounds the specified corners of an image.
   * @param {RoundCornersAction} roundCorners
   * @return {this}
   */
  roundCorners(roundCorners2) {
    this._roundCorners = roundCorners2;
    this._actionModel.radius = roundCorners2.getRadius();
    return this;
  }
  /**
   * @description Sets the style of the border.
   * @param {number | string} width The width in pixels.
   * @param {string} color The color of the border, e.g 'green', 'yellow'.
   * @return {this}
   */
  solid(width, color2) {
    this.borderType = "solid";
    this.borderColor = prepareColor(color2);
    this.borderWidth = width;
    this._actionModel.color = prepareColor(color2);
    this._actionModel.width = width;
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue([`${this.borderWidth}px`, this.borderType, `${this.borderColor}`]).setDelimiter("_");
    this.addQualifier(new Qualifier("bo", qualifierValue));
    if (this._roundCorners) {
      this.addQualifier(this._roundCorners.qualifiers.get("r"));
    }
  }
  static fromJson(actionModel) {
    const { width, color: color2, radius } = actionModel;
    const result = new this("solid", color2, width);
    if (radius) {
      const roundCornersAction = (() => {
        if (radius === "max") {
          return new RoundCornersAction_default().max();
        }
        if (Array.isArray(radius)) {
          return new RoundCornersAction_default().radius(...radius);
        }
        return void 0;
      })();
      if (roundCornersAction) {
        result.roundCorners(roundCornersAction);
      }
    }
    return result;
  }
};
function solid(width, color2) {
  return new BorderAction("solid", color2, width);
}
function roundCorners(roundCorners2) {
  const borderActionInstance = new BorderAction("solid", "transparent", 0);
  borderActionInstance.roundCorners(roundCorners2);
  return borderActionInstance;
}
var Border = {
  solid,
  roundCorners
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/roundCorners.js
function max() {
  return new RoundCornersAction_default().max();
}
function byRadius(a, b, c, d) {
  return new RoundCornersAction_default().radius(a, b, c, d);
}
var RoundCorners = { byRadius, max };

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/blur/Blur.js
var BlurAction = class extends Action {
  constructor(strength) {
    super();
    this._actionModel = {};
    this._strength = strength;
    this._actionModel.actionType = "blur";
    this._actionModel.strength = strength;
  }
  /**
   * @description Specifies the region to blur.
   * @param {NamedRegion} blurRegion
   */
  region(blurRegion) {
    this._actionModel.region = { RegionType: blurRegion.regionType };
    this._region = blurRegion;
    return this;
  }
  /**
   * @description Sets the strength of the blur effect.
   * @param {number | string} strength
   */
  strength(strength) {
    this._strength = strength;
    this._actionModel.strength = strength;
    return this;
  }
  prepareQualifiers() {
    const str = this._strength ? `:${this._strength}` : "";
    if ("_region" in this) {
      const qualifiers = this._region.qualifiers;
      qualifiers.forEach((q) => this.addQualifier(q));
      if (this._region.regionType === "named") {
        this.addQualifier(new Qualifier("e", `blur_region${str}`));
      }
      if (this._region.regionType === "ocr_text") {
        this.addQualifier(new Qualifier("e", `blur_region${str}`));
        this.addQualifier(new Qualifier("g", `ocr_text`));
      }
      if (this._region.regionType === "faces") {
        this.addQualifier(new Qualifier("e", `blur_faces${str}`));
      }
    } else {
      this.addQualifier(new Qualifier("e", `blur${str}`));
    }
  }
  static fromJson(actionModel) {
    const { actionType, strength, region } = actionModel;
    const result = new this(strength);
    strength && result.strength(strength);
    if (region && region.RegionType === "faces") {
      result.region(faces());
    }
    if (region && region.RegionType === "custom") {
      result.region(custom());
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/Accelerate.js
var AccelerationEffectAction = class extends Action {
  constructor(rate) {
    super();
    this._actionModel = { actionType: "accelerate" };
    rate && this.rate(rate);
  }
  rate(rate) {
    this._actionModel.rate = rate;
    this._rate = rate;
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue(["accelerate", this._rate]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
    return this;
  }
  static fromJson(actionModel) {
    const { rate } = actionModel;
    const result = new this();
    rate && result.rate(rate);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/EffectActions/SimpleEffectAction.js
var SimpleEffectAction = class extends Action {
  constructor(effectType, level) {
    super();
    this._actionModel = {};
    this._actionModel.actionType = EFFECT_MODE_TO_ACTION_TYPE_MAP[effectType] || effectType;
    const qualifierEffect = this.createEffectQualifier(effectType, level);
    this.addQualifier(qualifierEffect);
  }
  createEffectQualifier(effectType, level) {
    let qualifierValue;
    if (level) {
      qualifierValue = new QualifierValue([effectType, `${level}`]).setDelimiter(":");
    } else {
      qualifierValue = new QualifierValue(effectType);
    }
    return new Qualifier("e", qualifierValue);
  }
  static fromJson(actionModel) {
    const { actionType, level, strength } = actionModel;
    const effectType = ACTION_TYPE_TO_EFFECT_MODE_MAP[actionType] || actionType;
    const result = new this(effectType, level ? level : strength);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/EffectActions/LeveledEffectAction.js
var LeveledEffectAction = class extends SimpleEffectAction {
  constructor(effectType, level) {
    super(effectType, level);
    this.LEVEL_NAME = "level";
    this._actionModel = {};
    this.effectType = effectType;
    this._actionModel.actionType = EFFECT_MODE_TO_ACTION_TYPE_MAP[effectType] || effectType;
    if (level) {
      this.setLevel(level);
    }
  }
  /**
   *
   * @description Sets the effect level for the action
   * @param {string | number} level - The strength of the effect
   * @protected
   */
  setLevel(level) {
    this._actionModel[this.LEVEL_NAME] = level;
    const qualifierEffect = this.createEffectQualifier(this.effectType, level);
    this.addQualifier(qualifierEffect);
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/Loop.js
var LoopEffectAction = class extends LeveledEffectAction {
  additionalIterations(value) {
    this._actionModel.iterations = value;
    const qualifierEffect = this.createEffectQualifier(this.effectType, value);
    this.addQualifier(qualifierEffect);
    return this;
  }
  static fromJson(actionModel) {
    const { actionType, iterations } = actionModel;
    const result = new this(actionType, iterations);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Cartoonify.js
var CartoonifyEffect = class extends Action {
  constructor(effectName, strength) {
    super();
    this._actionModel = {};
    this.cartoonifyStrength = strength;
    this.effectName = effectName;
    this._actionModel.actionType = effectName;
  }
  /**
   * @description Sets the thickness of the lines.
   * @param {number} lineStrength The thickness of the lines. (Range: 0 to 100, Server default: 50)
   * @return {this}
   */
  lineStrength(lineStrength) {
    this.cartoonifyStrength = lineStrength;
    this._actionModel.lineStrength = lineStrength;
    return this;
  }
  /**
   * @description Achieves a black and white cartoon effect.
   * @return {this}
   */
  blackwhite() {
    this._actionModel.blackAndWhite = true;
    this.colorReduction = "bw";
    return this;
  }
  /**
   * @description
   * Sets the decrease in the number of colors and corresponding saturation boost of the remaining colors. <br/>
   * Higher reduction values result in a less realistic look.
   * @param {number } level The decrease in the number of colors and corresponding saturation boost of the remaining colors. (Range: 0 to 100, Server default: automatically adjusts according to the line_strength value). Set to 'bw' for a black and white cartoon effect.
   * @return {this}
   */
  colorReductionLevel(level) {
    this._actionModel.colorReductionLevel = level;
    this.colorReduction = level;
    return this;
  }
  prepareQualifiers() {
    this.addQualifier(new Qualifier("e", new QualifierValue([this.effectName, this.cartoonifyStrength, this.colorReduction])));
    return;
  }
  static fromJson(actionModel) {
    const { actionType, lineStrength, blackAndWhite, colorReductionLevel } = actionModel;
    const result = new this(actionType, lineStrength);
    blackAndWhite && result.blackwhite();
    colorReductionLevel && result.colorReductionLevel(colorReductionLevel);
    lineStrength && result.lineStrength(lineStrength);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Outline.js
var EffectOutline = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "outline";
  }
  /**
   * @description
   * How to apply the outline effect which can be one of the following values:
   * inner, inner_fill, outer, fill.
   * @param {OutlineModeType|string} mode  The type of outline effect. Use the constants defined in Outline.
   * @return {this}
   */
  mode(mode2) {
    this._actionModel.mode = mode2;
    this._mode = mode2;
    return this;
  }
  /**
   * The thickness of the outline in pixels. (Range: 1 to 100, Server default: 5)
   * @param {number} width
   * @return {this}
   */
  width(width) {
    this._actionModel.width = width;
    this._width = width;
    return this;
  }
  /**
   * @description
   * The level of blur of the outline.
   * Range: 0 to 2000, Server default: 0
   * @param {number | string} lvl
   * @return {this}
   */
  blurLevel(lvl) {
    this._actionModel.blurLevel = lvl;
    this._blurLevel = lvl;
    return this;
  }
  /**
   * @param {string | Qualifiers.Color} color One of the SDK Color values, string, or rgba: '#fff'
   * @return {this}
   */
  color(color2) {
    this._actionModel.color = color2;
    return this.addQualifier(new Qualifier("co", prepareColor(color2)));
  }
  prepareQualifiers() {
    this.addQualifier(new Qualifier("e", new QualifierValue(["outline", this._mode, this._width, this._blurLevel]).setDelimiter(":")));
  }
  static fromJson(actionModel) {
    const { actionType, mode: mode2, color: color2, blurLevel, width } = actionModel;
    const result = new this();
    mode2 && result.mode(mode2);
    color2 && result.color(color2);
    blurLevel && result.blurLevel(blurLevel);
    width && result.width(width);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/MakeTransparent.js
var MakeTransparentEffectAction = class extends LeveledEffectAction {
  constructor() {
    super(...arguments);
    this._actionModel = { actionType: "makeTransparent" };
  }
  /**
   * @description Sets the tolerance used to accommodate variance in the background color.
   * @param {number | string} value The tolerance used to accommodate variance in the background color. (Range: 0 to 100, Server default: 10)
   */
  tolerance(value) {
    this._actionModel.tolerance = value;
    const qualifierEffect = this.createEffectQualifier(this.effectType, value);
    this.addQualifier(qualifierEffect);
    return this;
  }
  /**
   * @description Sets the color to make transparent.
   * @param {string} color The HTML name of the color (red, green, etc.) or RGB hex code.
   * @return {this}
   */
  colorToReplace(color2) {
    this._actionModel.color = color2;
    return this.addQualifier(new Qualifier("co", new QualifierValue(prepareColor(color2))));
  }
  static fromJson(actionModel) {
    const { actionType, tolerance, color: color2 } = actionModel;
    const result = new this(ACTION_TYPE_TO_EFFECT_MODE_MAP[actionType], tolerance);
    tolerance && result.tolerance(tolerance);
    color2 && result.colorToReplace(color2);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Vectorize.js
var VectorizeEffectAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "vectorize";
  }
  /**
   * @description The number of colors. (Range: 2 to 30, Server default: 10)
   * @param {number | string} num
   * @return {this}
   */
  numOfColors(num) {
    this._actionModel.numOfColors = num;
    this._numOfColors = num;
    return this;
  }
  /**
   * @description The level of detail. Specify either a percentage of the original image (Range: 0.0 to 1.0) or an absolute number of pixels (Range: 0 to 1000). (Server default: 300)
   * @param {number | string} num
   * @return {this}
   */
  detailsLevel(num) {
    this._actionModel.detailLevel = num;
    this._detailsLevel = num;
    return this;
  }
  /**
   * @description The size of speckles to suppress. Specify either a percentage of the original image (Range: 0.0 to 1.0) or an absolute number of pixels (Range: 0 to 100, Server default: 2)
   * @param {number | string} num
   * @return {this}
   */
  despeckleLevel(num) {
    this._actionModel.despeckleLevel = num;
    this._despeckleLevel = num;
    return this;
  }
  /**
   * @description The corner threshold. Specify 100 for no smoothing (polygon corners), 0 for completely smooth corners. (Range: 0 to 100, Default: 25)
   * @param {number | string} num
   * @return {this}
   */
  cornersLevel(num) {
    this._actionModel.cornersLevel = num;
    this._cornersLevel = num;
    return this;
  }
  /**
   * @description The optimization value. Specify 100 for least optimization and the largest file. (Range: 0 to 100, Server default: 100).
   * @param {number} num
   * @return {this}
   */
  paths(num) {
    this._actionModel.paths = num;
    this._paths = num;
    return this;
  }
  prepareQualifiers() {
    let str = "vectorize";
    if (this._numOfColors) {
      str += `:${new QualifierValue(`colors:${this._numOfColors}`).toString()}`;
    }
    if (this._detailsLevel) {
      str += `:${new QualifierValue(`detail:${this._detailsLevel}`).toString()}`;
    }
    if (this._despeckleLevel) {
      str += `:${new QualifierValue(`despeckle:${this._despeckleLevel}`).toString()}`;
    }
    if (this._paths) {
      str += `:${new QualifierValue(`paths:${this._paths}`).toString()}`;
    }
    if (this._cornersLevel) {
      str += `:${new QualifierValue(`corners:${this._cornersLevel}`).toString()}`;
    }
    this.addQualifier(new Qualifier("e", str));
  }
  static fromJson(actionModel) {
    const { actionType, paths, cornersLevel, despeckleLevel, detailLevel, numOfColors } = actionModel;
    const result = new this();
    paths && result.paths(paths);
    cornersLevel && result.cornersLevel(cornersLevel);
    despeckleLevel && result.despeckleLevel(despeckleLevel);
    detailLevel && result.detailsLevel(detailLevel);
    numOfColors && result.numOfColors(numOfColors);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/SimulateColorBlind.js
var SimulateColorBlindEffectAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "simulateColorblind";
    this.addQualifier(new Qualifier("e", `simulate_colorblind`));
  }
  setQualifier(val) {
    const strToAppend = `:${val}`;
    if (val) {
      this.addQualifier(new Qualifier("e", `simulate_colorblind${strToAppend}`));
    }
    return this;
  }
  /**
   * @description Sets the color blind condition to simulate.
   * @param {Qualifiers.simulateColorBlindValues | SimulateColorBlindType | string} cond
   * @return {this}
   */
  condition(cond) {
    this._actionModel.condition = cond;
    return this.setQualifier(cond);
  }
  static fromJson(actionModel) {
    const { actionType, condition } = actionModel;
    const result = new this();
    condition && result.condition(condition);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/EffectActions/EffectActionWithLevel.js
var EffectActionWithLevel = class extends LeveledEffectAction {
  level(value) {
    this._actionModel.level = value;
    return this.setLevel(value);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/AssistColorBlind.js
var AssistColorBlindEffectAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "assistColorblind";
    this.addQualifier(new Qualifier("e", new QualifierValue("assist_colorblind")));
  }
  /**
   * @description Replaces problematic colors with colors that are easier to differentiate.
   * @return {this}
   */
  xray() {
    this._actionModel.type = "xray";
    return this.addQualifier(new Qualifier("e", new QualifierValue(["assist_colorblind", "xray"]).setDelimiter(":")));
  }
  /**
   * @description Applies stripes of the specified intensity to help people with common color blind conditions to differentiate between colors that are similar for them.
   * @param {number | string} strength The intensity of the stripes. (Range: 1 to 100, Server default: 10)
   * @return {this}
   */
  stripesStrength(strength) {
    this._actionModel.type = "stripes";
    this._actionModel.stripesStrength = strength;
    return this.addQualifier(new Qualifier("e", new QualifierValue(["assist_colorblind", strength]).setDelimiter(":")));
  }
  static fromJson(actionModel) {
    const { actionType, type, stripesStrength } = actionModel;
    const result = new this();
    if (type === "xray") {
      result.xray();
    }
    if (type === "stripes") {
      stripesStrength && result.stripesStrength(stripesStrength);
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/GradientFade.js
var GradientFadeEffectAction = class extends Action {
  constructor() {
    super(...arguments);
    this._actionModel = { actionType: "gradientFade" };
  }
  /**
   * @description Sets the strength of the fade effect.
   * @param {number} strength The strength of the fade effect. (Range: 0 to 100, Server default: 20)
   */
  strength(strength) {
    this._actionModel.strength = strength;
    this._strength = strength;
    return this;
  }
  /**
   * @description Sets the mode of gradient fade.
   * @param {string | Qualifiers.GradientFade} type The mode of gradient fade.
   */
  type(type) {
    this._actionModel.type = type;
    this._type = type;
    return this;
  }
  /**
   * @description Sets the x dimension of the start point.
   * @param {number | string} x The x dimension of the start point.
   */
  horizontalStartPoint(x) {
    this._actionModel.horizontalStartPoint = x;
    return this.addQualifier(new Qualifier("x", x));
  }
  /**
   * @description Sets the y dimension of the start point.
   * @param {number | string} y The y dimension of the start point.
   */
  verticalStartPoint(y) {
    this._actionModel.verticalStartPoint = y;
    return this.addQualifier(new Qualifier("y", y));
  }
  prepareQualifiers() {
    let str = "gradient_fade";
    if (this._type) {
      str += `:${this._type}`;
    }
    if (this._strength) {
      str += `:${this._strength}`;
    }
    this.addQualifier(new Qualifier("e", str));
  }
  static fromJson(actionModel) {
    const { actionType, verticalStartPoint, horizontalStartPoint, type, strength } = actionModel;
    const result = new this();
    verticalStartPoint && result.verticalStartPoint(verticalStartPoint);
    horizontalStartPoint && result.horizontalStartPoint(horizontalStartPoint);
    type && result.type(type);
    strength && result.strength(strength);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/FadeOut.js
var FadeOutEffectAction = class extends Action {
  constructor(duration) {
    super();
    this._actionModel = { actionType: "fadeOut" };
    this.addQualifier(new Qualifier("e", new QualifierValue(["fade", `-${duration}`]).setDelimiter(":")));
    duration && (this._actionModel.length = duration);
  }
  /**
   *
   * @description Sets the duration level for the action
   * @param {string | number} duration - The duration of the effect
   */
  duration(duration) {
    this._actionModel.length = duration;
    return this.addQualifier(new Qualifier("e", new QualifierValue(["fade", `-${duration}`]).setDelimiter(":")));
  }
  static fromJson(actionModel) {
    const { length } = actionModel;
    if (length === void 0) {
      return new this(1e3);
    }
    const result = new this(length);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Colorize.js
var ColorizeEffectAction = class extends EffectActionWithLevel {
  /**
   * @description The color to use for colorization. Specify HTML name or RGB hex code. (Server default: gray)
   * @param {string} color HTML name(red, green, etc.) or RGB hex code. (Server default: gray)
   * @return {this}
   */
  color(color2) {
    this._actionModel.color = color2;
    return this.addQualifier(new Qualifier("co", new QualifierValue(prepareColor(color2))));
  }
  static fromJson(actionModel) {
    const { actionType, level, color: color2 } = actionModel;
    const result = new this(actionType, level);
    color2 && result.color(color2);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Shadow.js
var ShadowEffectAction = class extends Action {
  constructor(effectType, strength) {
    super();
    this._actionModel = {};
    this._actionModel.actionType = effectType;
    this.effectType = effectType;
    this.addQualifier(new Qualifier("e", new QualifierValue(["shadow", strength])));
  }
  /**
   * @description The strength of the shadow. (Range: 0 to 100, Server default: 40)
   * @param {number} strength
   * @return {this}
   */
  strength(strength) {
    this._actionModel.strength = strength;
    return this.addQualifier(new Qualifier("e", new QualifierValue(["shadow", strength])));
  }
  /**
   * @description The X offset the shadow
   * @param {number | SDK.ExpressionQualifier} x
   * @return {this}
   */
  offsetX(x) {
    this._actionModel.offsetX = x;
    return this.addQualifier(new Qualifier("x", new QualifierValue(x)));
  }
  /**
   * @description The Y offset the shadow
   * @param {number | SDK.ExpressionQualifier} y
   * @return {this}
   */
  offsetY(y) {
    this._actionModel.offsetY = y;
    return this.addQualifier(new Qualifier("y", new QualifierValue(y)));
  }
  /**
   * @description The color of the shadow (Server default: gray)
   * @param color
   * @return {this}
   */
  color(color2) {
    this._actionModel.color = color2;
    return this.addQualifier(new Qualifier("co", new QualifierValue(prepareColor(color2))));
  }
  static fromJson(actionModel) {
    const { actionType, strength, offsetX, offsetY, color: color2 } = actionModel;
    const result = new this(actionType, strength);
    offsetX && result.offsetX(offsetX);
    offsetY && result.offsetY(offsetY);
    color2 && result.color(color2);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/StyleTransfer.js
var StyleTransfer = class extends Action {
  /**
   * The Image Source used to create the style transfer,
   * Use the Image Source builder to quickly create a source:
   * </br>Import: {@link Qualifiers.Source|import Sources from '@cloudinary/url-gen/qualifiers/sources';}
   * </br>Create: `Source.image('dog')`
   * @param {ImageSource} imageSource
   */
  constructor(imageSource) {
    super();
    this.imageSource = imageSource;
  }
  /**
   * Determines the strength in which the styleTransfer is applied.
   * @param {number} [effectStrength] - The strength level, 1-100, default: 100
   * @return {this}
   */
  strength(effectStrength = null) {
    this.effectStrength = effectStrength;
    return this;
  }
  /**
   * More aggressively preserves the colors of the the target photo,
   * Can be used with `strength()` to enhance this behaviour
   * @param {boolean} bool
   * @return {this}
   */
  preserveColor(bool = true) {
    this.preserve = bool;
    return this;
  }
  /**
   * The `build` phase of the Action, used internally to concat all the options received into a single string.
   * The result of this method is the toString() of the imageLayer provided in the constructor.
   * @return {string}
   */
  toString() {
    const NAME = "style_transfer";
    const PRES = this.preserve ? "preserve_color" : null;
    const STRENGTH = this.effectStrength;
    const styleEffect = new Qualifier("e", new QualifierValue([NAME, PRES, STRENGTH]));
    const sourceOpenString = this.imageSource.getOpenSourceString("l");
    const imgTx = this.imageSource.getTransformation();
    const sourceTransformation = imgTx ? imgTx.toString() : "";
    return [
      sourceOpenString,
      sourceTransformation,
      `${styleEffect},fl_layer_apply`
    ].filter((a) => a).join("/");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Dither.js
var DitherEffectAction = class extends LeveledEffectAction {
  constructor() {
    super(...arguments);
    this._actionModel = { actionType: "dither" };
  }
  /**
   *
   * @param {Qualifiers.Dither} ditherType - The dither type applied to the image
   * @return {this}
   */
  type(ditherType) {
    this._actionModel.type = ditherType;
    const qualifierEffect = this.createEffectQualifier(this.effectType, ditherType);
    this.addQualifier(qualifierEffect);
    return this;
  }
  static fromJson(actionModel) {
    const { actionType, type } = actionModel;
    const result = new this(actionType);
    type && result.type(type);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/Deshake.js
var DeshakeEffectAction = class extends LeveledEffectAction {
  constructor() {
    super(...arguments);
    this._actionModel = { actionType: "deshake" };
  }
  /**
   * The maximum number of pixels in the horizontal and vertical direction that will be addressed. (Possible values: 16, 32, 48, 64. Server default: 16)
   * @param value Possible values: 16, 32, 48, 64.  Server default: 16.
   */
  shakeStrength(value) {
    this._actionModel.pixels = value;
    const qualifierEffect = this.createEffectQualifier(this.effectType, value);
    this.addQualifier(qualifierEffect);
    return this;
  }
  static fromJson(actionModel) {
    const { actionType, pixels } = actionModel;
    const result = new this(actionType, pixels);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/pixelate/Pixelate.js
var Pixelate = class extends Action {
  constructor(squareSize) {
    super();
    this._actionModel = {};
    this._squareSize = squareSize;
    this._actionModel.actionType = "pixelate";
    this._actionModel.squareSize = squareSize;
  }
  /**
   * @description Specifies the region to piexlate.
   * @param {NamedRegion} pixelateRegion
   */
  region(pixelateRegion) {
    this._region = pixelateRegion;
    this._actionModel.region = { RegionType: this._region.regionType };
    return this;
  }
  /**
   * @description Sets the squareSize of the pixelate effect.
   * @param {number | string} squareSize
   */
  squareSize(squareSize) {
    this._squareSize = squareSize;
    this._actionModel.squareSize = squareSize;
    return this;
  }
  prepareQualifiers() {
    const str = this._squareSize ? `:${this._squareSize}` : "";
    if ("_region" in this) {
      const qualifiers = this._region.qualifiers;
      qualifiers.forEach((q) => this.addQualifier(q));
      if (this._region.regionType === "named") {
        this.addQualifier(new Qualifier("e", `pixelate_region${str}`));
      }
      if (this._region.regionType === "ocr_text") {
        this.addQualifier(new Qualifier("e", `pixelate_region${str}`));
        this.addQualifier(new Qualifier("g", `ocr_text`));
      }
      if (this._region.regionType === "faces") {
        this.addQualifier(new Qualifier("e", `pixelate_faces${str}`));
      }
    } else {
      this.addQualifier(new Qualifier("e", `pixelate${str}`));
    }
  }
  static fromJson(actionModel) {
    const { actionType, region, squareSize } = actionModel;
    const result = new this(squareSize);
    squareSize && result.squareSize(squareSize);
    if (region && region.RegionType === "faces") {
      result.region(faces());
    }
    if (region && region.RegionType === "custom") {
      result.region(custom());
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/EffectActions/EffectActionWithStrength.js
var EffectActionWithStrength = class extends LeveledEffectAction {
  constructor() {
    super(...arguments);
    this.LEVEL_NAME = "strength";
  }
  strength(value) {
    return this.setLevel(value);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/Blackwhite.js
var BlackwhiteEffectAction = class extends LeveledEffectAction {
  threshold(value) {
    return this.setLevel(value);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/FadeIn.js
var FadeInEffectAction = class extends Action {
  constructor(duration) {
    super();
    this._actionModel = { actionType: "fadeIn" };
    this.addQualifier(new Qualifier("e", new QualifierValue(["fade", `${duration}`]).setDelimiter(":")));
    duration && (this._actionModel.length = duration);
  }
  /**
   *
   * @description Sets the duration level for the action
   * @param {string | number} duration - The duration of the effect
   */
  duration(duration) {
    this._actionModel.length = duration;
    return this.addQualifier(new Qualifier("e", new QualifierValue(["fade", `${duration}`]).setDelimiter(":")));
  }
  static fromJson(actionModel) {
    const { length } = actionModel;
    if (length === void 0) {
      return new this(1e3);
    }
    const result = new this(length);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/RemoveBackgroundAction.js
var RemoveBackgroundAction = class extends Action {
  constructor() {
    super();
    this.overwriteQualifier();
  }
  /**
   * @description Everytime this method is called, it will overwrite the e_bgremoval qualifier with new values
   * @private
   */
  overwriteQualifier() {
    const value = ["bgremoval", this._screen ? "screen" : "", (this._colorToRemove || "").replace("#", "")];
    return this.addQualifier(new Qualifier("e", new QualifierValue(value)));
  }
  /**
   * @description The strength of the shadow. (Range: 0 to 100, Server default: 40)
   * @param {number} useScreen Boolean, defaults to true
   * @return {this}
   */
  screen(useScreen = true) {
    this._screen = useScreen;
    return this.overwriteQualifier();
  }
  /**
   * @description The color to remove from the background
   * @param {SystemColors} color
   * @return {this}
   */
  colorToRemove(color2) {
    this._colorToRemove = color2;
    return this.overwriteQualifier();
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Theme.js
var ThemeEffect = class extends Action {
  constructor(color2) {
    super();
    this.effectName = "theme";
    this.color = color2;
  }
  /**
   * @description The sensitivity to photographic elements of an image.
   *              A value of 0 treats the whole image as non-photographic.
   *              A value of 200 treats the whole image as photographic, so no theme change is applied.
   * @param {number} photosensitivity
   * @return {this}
   */
  photosensitivity(photosensitivity) {
    this._photosensitivity = photosensitivity;
    return this;
  }
  prepareQualifiers() {
    const sensitivity = this._photosensitivity ? `:photosensitivity_${this._photosensitivity}` : "";
    const val = `${this.effectName}:color_${this.color.replace("#", "")}${sensitivity}`;
    this.addQualifier(new Qualifier("e", new QualifierValue(val)));
    return;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/BackgroundRemoval.js
var BackgroundRemoval = class extends Action {
  constructor() {
    super();
    this._actionModel.actionType = "backgroundRemoval";
  }
  fineEdges(value = true) {
    this._fineEdges = value;
    this._actionModel.fineEdges = this._fineEdges;
    return this;
  }
  hints(value) {
    this._hints = value;
    if (this._hints) {
      this._actionModel.hints = this._hints;
    }
    return this;
  }
  prepareQualifiers() {
    var _a;
    let str = "background_removal";
    if (this._fineEdges !== void 0) {
      str += `:${new QualifierValue(`fineedges_${this._fineEdges ? "y" : "n"}`).toString()}`;
    }
    if ((_a = this._hints) === null || _a === void 0 ? void 0 : _a.length) {
      str += `:${new QualifierValue(`hints_(${this._hints.join(";")})`).toString()}`;
    }
    this.addQualifier(new Qualifier("e", str));
  }
  static fromJson(actionModel) {
    const { fineEdges, hints } = actionModel;
    const result = new this();
    if (fineEdges !== void 0) {
      result.fineEdges(fineEdges);
    }
    result.hints(hints);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/DropShadow.js
var DropShadow = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "dropshadow";
  }
  /**
   * @description
   * The direction the light is coming from to cause the shadow effect. (Range: 0 to 360, Server default: 215)
   * @param {number} azimuth
   * @return {this}
   */
  azimuth(azimuth) {
    this._actionModel.azimuth = azimuth;
    this._azimuth = azimuth;
    return this;
  }
  /**
   * @description
   * The height of the light source above the 'ground' to cause the shadow effect. (Range: 0 to 90, Server default: 45)
   * @param {number} elevation
   * @return {this}
   */
  elevation(elevation) {
    this._actionModel.elevation = elevation;
    this._elevation = elevation;
    return this;
  }
  /**
   * @description
   * The spread of the light source. A small number means 'point' light. A larger number means 'area' light. (Range: 0 to 100, Server default: 50)
   * @param {number} spread
   * @return {this}
   */
  spread(spread) {
    this._actionModel.spread = spread;
    this._spread = spread;
    return this;
  }
  prepareQualifiers() {
    const paramNames = ["azimuth", "elevation", "spread"];
    const paramValues = [this._azimuth, this._elevation, this._spread];
    const paramString = paramValues.map((value, index) => value !== void 0 ? `${paramNames[index]}_${value}` : "").filter(Boolean).join(";");
    this.addQualifier(new Qualifier("e", new QualifierValue(["dropshadow", paramString]).setDelimiter(":")));
  }
  static fromJson(actionModel) {
    const { azimuth, elevation, spread } = actionModel;
    const result = new this();
    azimuth && result.azimuth(azimuth);
    elevation && result.elevation(elevation);
    spread && result.spread(spread);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect.js
function blur(blurLevel) {
  return new BlurAction(blurLevel);
}
function grayscale() {
  return new SimpleEffectAction("grayscale");
}
function sepia(level) {
  return new EffectActionWithLevel("sepia", level);
}
function shadow(shadowLevel) {
  return new ShadowEffectAction("shadow", shadowLevel);
}
function colorize(colorizeLevel) {
  return new ColorizeEffectAction("colorize", colorizeLevel);
}
function oilPaint(oilPaintLevel) {
  return new EffectActionWithStrength("oil_paint", oilPaintLevel);
}
function artisticFilter(artisticFilterType) {
  return new SimpleEffectAction("art", artisticFilterType);
}
function cartoonify(cartoonifyLevel) {
  return new CartoonifyEffect("cartoonify", cartoonifyLevel);
}
function outline() {
  return new EffectOutline();
}
function styleTransfer(imageSource) {
  return new StyleTransfer(imageSource);
}
function boomerang() {
  return new SimpleEffectAction("boomerang");
}
function advancedRedEye() {
  return new SimpleEffectAction("adv_redeye");
}
function blackwhite(level) {
  return new BlackwhiteEffectAction("blackwhite", level);
}
function negate() {
  return new SimpleEffectAction("negate");
}
function redEye() {
  return new SimpleEffectAction("redeye");
}
function reverse() {
  return new SimpleEffectAction("reverse");
}
function accelerate(speedIncreasePercent) {
  return new AccelerationEffectAction(speedIncreasePercent);
}
function fadeIn(fadeLength) {
  return new FadeInEffectAction(fadeLength);
}
function fadeOut(fadeLength) {
  return new FadeOutEffectAction(fadeLength);
}
function loop(additionalLoops) {
  return new LoopEffectAction("loop", additionalLoops);
}
function makeTransparent(tolerance) {
  return new MakeTransparentEffectAction("make_transparent", tolerance);
}
function noise(percentage) {
  return new EffectActionWithLevel("noise", percentage);
}
function vignette(strength) {
  return new EffectActionWithStrength("vignette", strength);
}
function dither(ditherType) {
  return new DitherEffectAction("ordered_dither", ditherType);
}
function vectorize() {
  return new VectorizeEffectAction();
}
function gradientFade() {
  return new GradientFadeEffectAction();
}
function assistColorBlind() {
  return new AssistColorBlindEffectAction();
}
function simulateColorBlind() {
  return new SimulateColorBlindEffectAction();
}
function deshake(pixels) {
  return new DeshakeEffectAction("deshake", pixels);
}
function transition() {
  return new SimpleEffectAction("transition");
}
function pixelate(squareSize) {
  return new Pixelate(squareSize);
}
function removeBackground() {
  return new RemoveBackgroundAction();
}
function backgroundRemoval() {
  return new BackgroundRemoval();
}
function dropShadow() {
  return new DropShadow();
}
function theme(color2) {
  return new ThemeEffect(color2);
}
var Effect = {
  pixelate,
  deshake,
  boomerang,
  advancedRedEye,
  blackwhite,
  negate,
  redEye,
  reverse,
  accelerate,
  fadeIn,
  fadeOut,
  loop,
  makeTransparent,
  noise,
  vignette,
  blur,
  grayscale,
  sepia,
  shadow,
  colorize,
  oilPaint,
  artisticFilter,
  cartoonify,
  outline,
  styleTransfer,
  gradientFade,
  vectorize,
  assistColorBlind,
  simulateColorBlind,
  transition,
  dither,
  removeBackground,
  backgroundRemoval,
  dropShadow,
  theme
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/rotate/RotateAction.js
var QUALIFIER_KEY = "a";
var RotateAction = class extends Action {
  constructor(angle) {
    super();
    this._actionModel = {};
    this.addQualifier(new Qualifier(QUALIFIER_KEY, angle));
    this._actionModel.actionType = "rotateByAngle";
    if (angle) {
      this._actionModel.angle = angle;
    }
  }
  /**
   * @description Rotates an asset using a defined mode.
   * @param {Qualifiers.RotationMode | RotationModeType | string} rotationMode
   * For a list of supported rotation modes see {@link Qualifiers.RotationMode| types of rotation modes} for
   * possible values
   * @return {this}
   */
  mode(rotationMode) {
    return this.addValueToQualifier(QUALIFIER_KEY, rotationMode);
  }
  /**
   * @description Rotates an asset by the specified degrees.
   * @param {number} degrees rotation in degrees e.g 90, 45, 33
   * @return {this}
   */
  angle(degrees) {
    this._actionModel.angle = degrees;
    return this.addValueToQualifier(QUALIFIER_KEY, degrees);
  }
  static fromJson(actionModel) {
    const { angle } = actionModel;
    const result = new this(angle);
    return result;
  }
};
var RotateAction_default = RotateAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/rotate.js
function mode(rotationMode) {
  return new RotateAction_default().mode(rotationMode);
}
function byAngle(angle) {
  return new RotateAction_default(angle);
}
var Rotate = { byAngle, mode };

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/FillLightAction.js
var FillLightAction = class extends Action {
  constructor() {
    super();
  }
  /**
   * @description Sets the level of adjustment
   * @param {number} lvl How much to blend the adjusted fill light, where 0 means only use the original and 100 means only use the adjusted fill light result. (Range: 0 to 100, Server default: 100)
   */
  blend(blend) {
    this.lvl = blend;
    return this;
  }
  /**
   * @description Sets the level of the bias
   * @param {number} biasLvl The bias to apply to the fill light effect (Range: -100 to 100, Server default: 0).
   */
  bias(biasLvl) {
    this.biasLvl = biasLvl;
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue(["fill_light", this.lvl, this.biasLvl]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/RecolorAction.js
var RecolorAction = class extends Action {
  constructor(recolorMatrix) {
    super();
    this.matrix = recolorMatrix;
    const flat = [];
    for (let row = 0; row < recolorMatrix.length; row++) {
      for (let col = 0; col < recolorMatrix[row].length; col++) {
        flat.push(recolorMatrix[row][col].toString());
      }
    }
    const qualifierValue = new QualifierValue(["recolor", ...flat]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/OpacityAdjustAction.js
var OpacityAdjustAction = class extends Action {
  constructor(level) {
    super();
    this._actionModel = { actionType: "opacity" };
    this.level = level;
    this._actionModel.level = level;
    this.addQualifier(new Qualifier("o", level));
  }
  static fromJson(actionModel) {
    const { level } = actionModel;
    return new this(level);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/By3dLutAction.js
var By3dLutAction = class extends Action {
  constructor(publicId) {
    super();
    this.publicId = publicId;
  }
  /**
   * Returns a string representation of the action
   * @return {string}
   */
  toString() {
    return `l_lut:${this.publicId}/fl_layer_apply`;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/ImproveAction.js
var ImproveAction = class extends Action {
  constructor() {
    super();
    this._actionModel = { actionType: "improve" };
  }
  /**
   *
   * @description The improve mode.
   * @param {Qualifiers.ImproveMode | string} value
   */
  mode(value) {
    this.modeValue = value;
    this._actionModel.mode = value;
    return this;
  }
  /**
   * @description How much to blend the improved result with the original image, where 0 means only use the original and 100 means only use the improved result. (Range: 0 to 100, Server default: 100)
   * @param {number} value
   */
  blend(value) {
    this.blendValue = value;
    this._actionModel.blend = value;
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue(["improve", this.modeValue, this.blendValue]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
    return this;
  }
  static fromJson(actionModel) {
    const { mode: mode2, blend } = actionModel;
    const result = new this();
    mode2 && result.mode(mode2);
    blend && result.blend(blend);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/ReplaceColorAction.js
var ReplaceColorAction = class extends Action {
  /**
   * @description Sets the target output color.
   * @param {string} toColor - The HTML name or RGB/A hex code of the target output color.
   */
  constructor(toColor) {
    super();
    this.targetColor = toColor;
  }
  /**
   * @description Sets the tolerance threshold.
   * @param {number} toleranceLevel - The tolerance threshold (a radius in the LAB color space) from the input color, </br>
   *                                  representing the span of colors that should be replaced with a correspondingly adjusted version of the target output color. </br>
   *                                  Larger values result in replacing more colors within the image. </br>
   *                                  The more saturated the original input color, the more a change in value will impact the result (Server default: 50).
   * @return {this}
   */
  tolerance(toleranceLevel) {
    this.toleranceLevel = toleranceLevel;
    return this;
  }
  /**
   * @description Sets the base input color to map.
   * @param {string} baseColor - The HTML name or RGB/A hex code of the base input color to map (Server default: the most prominent high-saturation color in the image).
   * @return {this}
   */
  fromColor(baseColor) {
    this.baseColor = baseColor;
    return this;
  }
  prepareQualifiers() {
    const targetColor = this.targetColor && this.targetColor.toString().replace("#", "");
    const baseColor = this.baseColor && this.baseColor.toString().replace("#", "");
    const qualifierValue = new QualifierValue(["replace_color", targetColor, this.toleranceLevel, baseColor]);
    this.addQualifier(new Qualifier("e", qualifierValue));
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/EffectActions/EffectActionWithBlend.js
var EffectActionWithBlend = class extends LeveledEffectAction {
  blend(value) {
    return this.setLevel(value);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/simple/ViesusCorrectAdjustAction.js
var ViesusCorrectAdjustAction = class extends Action {
  /**
   * @description Enhances the image without correcting for red eye.
   */
  noRedEye() {
    this._noRedEye = true;
    return this;
  }
  /**
   * @description Applies saturation to the skin tones in the image.
   * @param level The saturation level. (Range: -100 to 100, Server default: 50).
   */
  skinSaturation(level) {
    this._skinSaturation = true;
    if (level) {
      this._skinSaturationLevel = level;
    }
    return this;
  }
  prepareQualifiers() {
    let value = "viesus_correct";
    if (this._noRedEye) {
      value += ":no_redeye";
    }
    if (this._skinSaturation) {
      value += ":skin_saturation";
      if (typeof this._skinSaturationLevel !== "undefined") {
        value += `_${this._skinSaturationLevel}`;
      }
    }
    this.addQualifier(new Qualifier("e", value));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust.js
function tint(value = "") {
  return new SimpleEffectAction("tint", value);
}
function brightness(level) {
  return new EffectActionWithLevel("brightness", level);
}
function viesusCorrect() {
  return new ViesusCorrectAdjustAction();
}
function red(level) {
  return new EffectActionWithLevel("red", level);
}
function sharpen(strength) {
  return new EffectActionWithStrength("sharpen", strength);
}
function saturation(level) {
  return new EffectActionWithLevel("saturation", level);
}
function contrast(level) {
  return new EffectActionWithLevel("contrast", level);
}
function gamma(level) {
  return new EffectActionWithLevel("gamma", level);
}
function blue(level) {
  return new EffectActionWithLevel("blue", level);
}
function brightnessHSB(level) {
  return new EffectActionWithLevel("brightness_hsb", level);
}
function opacityThreshold(level) {
  return new EffectActionWithLevel("opacity_threshold", level);
}
function autoColor(blend) {
  return new EffectActionWithBlend("auto_color", blend);
}
function autoBrightness(blend) {
  return new EffectActionWithBlend("auto_brightness", blend);
}
function hue(level) {
  return new EffectActionWithLevel("hue", level);
}
function green(level) {
  return new EffectActionWithLevel("green", level);
}
function unsharpMask(strength) {
  return new EffectActionWithStrength("unsharp_mask", strength);
}
function vibrance(strength) {
  return new EffectActionWithStrength("vibrance", strength);
}
function autoContrast(blend) {
  return new EffectActionWithBlend("auto_contrast", blend);
}
function opacity(level) {
  return new OpacityAdjustAction(level);
}
function improve() {
  return new ImproveAction();
}
function replaceColor(toColor) {
  return new ReplaceColorAction(toColor);
}
function recolor(matrix) {
  return new RecolorAction(matrix);
}
function fillLight() {
  return new FillLightAction();
}
function by3dLut(publicId) {
  return new By3dLutAction(publicId);
}
var Adjust = {
  brightness,
  viesusCorrect,
  opacity,
  red,
  sharpen,
  improve,
  saturation,
  contrast,
  gamma,
  green,
  blue,
  brightnessHSB,
  hue,
  autoBrightness,
  autoColor,
  autoContrast,
  vibrance,
  unsharpMask,
  opacityThreshold,
  replaceColor,
  recolor,
  fillLight,
  by3dLut,
  tint
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/underlay.js
function source(source2) {
  return new LayerAction(source2).setLayerType("u");
}
var Underlay = { source };

// node_modules/@cloudinary/transformation-builder-sdk/actions/namedTransformation/NamedTransformationAction.js
var NamedTransformationAction = class extends Action {
  /**
   *
   * @param {string} name The name of the named transformation
   */
  constructor(name2) {
    super();
    this.addQualifier(new Qualifier("t", name2));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/namedTransformation.js
function name(name2) {
  return new NamedTransformationAction(name2);
}
var NamedTransformation = { name };

// node_modules/@cloudinary/transformation-builder-sdk/actions/customFunction/CustomFunctionAction.js
var CustomFunctionAction = class extends Action {
  /**
   *
   * @param {string} fn The custom function to use, can be a URL or a publicID
   */
  constructor(fn) {
    super();
    this.fn = fn;
  }
  encodeCustomFunctionString(fn) {
    const encodedSource = base64Encode(fn);
    return encodedSource;
  }
  /**
   * Use a WASM as a custom function,
   * Used with the builders of `remote` and `wasm` from {@link Actions.CustomFunction|Custom functions}
   */
  asWasm() {
    this.mode = "wasm";
    return this;
  }
  /**
   * Use a remote URL as a custom function
   * Used with the builders of `remote` and `wasm` from {@link Actions.CustomFunction|Custom functions}
   */
  asRemote() {
    this.mode = "remote";
    return this;
  }
  prepareQualifiers() {
    this.encodedFn = this.fn;
    if (this.mode === "remote") {
      this.encodedFn = this.encodeCustomFunctionString(this.fn);
    }
    return this.addQualifier(new Qualifier("fn", new QualifierValue([this.pre, this.mode, this.encodedFn])));
  }
  toString() {
    return super.toString().replace(/\//g, ":");
  }
};
var CustomFunctionAction_default = CustomFunctionAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/customFunction/RemoteAction.js
var RemoteAction = class extends CustomFunctionAction_default {
  constructor(fn) {
    super(fn);
  }
  preprocess() {
    this.pre = "pre";
    return this;
  }
};
var RemoteAction_default = RemoteAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/customFunction.js
function remote(path) {
  return new RemoteAction_default(path).asRemote();
}
function wasm(publicID) {
  return new CustomFunctionAction_default(publicID).asWasm();
}
var CustomFunction = { remote, wasm };

// node_modules/@cloudinary/transformation-builder-sdk/actions/videoEdit/TrimAction.js
var TrimAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {
      actionType: "trimVideo"
    };
  }
  /**
   *
   * @description Support Percentages in values (30% -> 30p)
   * @param {string|number} val
   * @private
   * @return {string}
   */
  parseVal(val) {
    return typeof val === "number" ? val : val.replace("%", "p");
  }
  /**
   * @description Sets the starting position of the part of the video to keep when trimming videos.
   *
   * @param {string|number} offset The starting position of the part of the video to keep. This can be specified as a
   *                           float representing the time in seconds or a string representing the percentage of the
   *                           video length (for example, "30%" or "30p").
   * @return {this}
   */
  startOffset(offset) {
    this._actionModel.startOffset = +offset;
    return this.addQualifier(new Qualifier("so", this.parseVal(offset)));
  }
  /**
   * @description Sets the end position of the part of the video to keep when trimming videos.
   *
   * @param {string|number} offset The end position of the part of the video to keep. This can be specified as a
   *                         float representing the time in seconds or a string representing the percentage of the
   *                         video length (for example, "30%" or "30p").
   * @return {this}
   */
  endOffset(offset) {
    this._actionModel.endOffset = +offset;
    return this.addQualifier(new Qualifier("eo", this.parseVal(offset)));
  }
  /**
   * @description Sets the duration of the video to keep.
   *
   * @param {string|number} duration The length of the part of the video to keep. This can be specified as a float
   *                        representing the time in seconds or a string representing the percentage of the
   *                        video length (for example, "30%" or "30p").
   * @return {this}
   */
  duration(duration) {
    this._actionModel.duration = duration;
    return this.addQualifier(new Qualifier("du", this.parseVal(duration)));
  }
  static fromJson(actionModel) {
    const { duration, startOffset, endOffset } = actionModel;
    const result = new this();
    if (duration != null) {
      result.duration(duration);
    }
    if (startOffset != null) {
      result.startOffset(startOffset);
    }
    if (endOffset != null) {
      result.endOffset(endOffset);
    }
    return result;
  }
};
var TrimAction_default = TrimAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/background/actions/BackgroundColor.js
var BackgroundColor = class extends Action {
  constructor(color2) {
    super();
    this.addQualifier(new Qualifier("b", new QualifierValue(color2).setDelimiter("_")));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/RawAction.js
var RawAction = class {
  constructor(raw) {
    this.raw = raw;
  }
  toString() {
    return this.raw;
  }
  toJson() {
    return { error: createUnsupportedError(`unsupported action ${this.constructor.name}`) };
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/IErrorObject.js
function isErrorObject(obj) {
  const errorObj = obj;
  return "error" in errorObj && !!errorObj.error;
}

// node_modules/@cloudinary/transformation-builder-sdk/transformation/Transformation.js
var Transformation = class {
  constructor() {
    this.actions = [];
  }
  /**
   * @param {SDK.Action | string} action
   * @return {this}
   */
  addAction(action) {
    let actionToAdd;
    if (typeof action === "string") {
      if (action.indexOf("/") >= 0) {
        throw "addAction cannot accept a string with a forward slash in it - /, use .addTransformation() instead";
      } else {
        actionToAdd = new RawAction(action);
      }
    } else {
      actionToAdd = action;
    }
    this.actions.push(actionToAdd);
    return this;
  }
  /**
   * @description Allows the injection of a raw transformation as a string into the transformation, or a Transformation instance that was previously created
   * @param {string | SDK.Transformation} tx
   * @example
   * import {Transformation} from "@cloudinary/url-gen";
   *
   * const transformation = new Transformation();
   * transformation.addTransformation('w_100/w_200/w_300');
   * @return {this}
   */
  addTransformation(tx) {
    if (tx instanceof Transformation) {
      this.actions = this.actions.concat(tx.actions);
    } else {
      this.actions.push(new RawAction(tx));
    }
    return this;
  }
  /**
   * @return {string}
   */
  toString() {
    return this.actions.map((action) => {
      return action.toString();
    }).filter((a) => a).join("/");
  }
  /**
   * @description Delivers an animated GIF.
   * @param {AnimatedAction} animatedAction
   * @return {this}
   */
  animated(animatedAction) {
    return this.addAction(animatedAction);
  }
  /**
   * @description Adds a border around the image.
   * @param {Border} borderAction
   * @return {this}
   */
  border(borderAction) {
    return this.addAction(borderAction);
  }
  /**
   * @description Adjusts the shape of the delivered image. </br>
   * <b>Learn more:</b> {@link https://cloudinary.com/documentation/effects_and_artistic_enhancements#distort|Shape changes and distortion effects}
   * @param {IReshape} reshapeAction
   * @return {this}
   */
  reshape(reshapeAction) {
    return this.addAction(reshapeAction);
  }
  /**
   * @description Resize the asset using provided resize action
   * @param {ResizeSimpleAction} resizeAction
   * @return {this}
   */
  resize(resizeAction) {
    return this.addAction(resizeAction);
  }
  /**
   * @desc An alias to Action Delivery.quality
   * @param {string|number} quality
   * @return {this}
   */
  quality(quality) {
    this.addAction(new DeliveryFormatAction("q", quality));
    return this;
  }
  /**
   * @desc An alias to Action Delivery.format
   * @param {string} format
   * @return {this}
   */
  format(format) {
    this.addAction(new DeliveryFormatAction("f", format));
    return this;
  }
  /**
   * @description Rounds the specified corners of an image.
   * @param roundCornersAction
   * @return {this}
   */
  roundCorners(roundCornersAction) {
    return this.addAction(roundCornersAction);
  }
  /**
   * @description Adds an overlay over the base image.
   * @param {LayerAction} overlayAction
   * @return {this}
   */
  overlay(overlayAction) {
    return this.addAction(overlayAction);
  }
  /**
   * @description Adds an underlay under the base image.
   * @param {LayerAction} underlayAction
   * @return {this}
   */
  underlay(underlayAction) {
    underlayAction.setLayerType("u");
    return this.addAction(underlayAction);
  }
  /**
   * @description Defines an new user variable.
   * @param {VariableAction} variableAction
   * @return {this}
   */
  addVariable(variableAction) {
    return this.addAction(variableAction);
  }
  /**
   * @description Specifies a condition to be met before applying a transformation.
   * @param {ConditionalAction} conditionAction
   * @return {this}
   */
  conditional(conditionAction) {
    return this.addAction(conditionAction);
  }
  /**
   * @description Applies a filter or an effect on an asset.
   * @param {SimpleEffectAction} effectAction
   * @return {this}
   */
  effect(effectAction) {
    return this.addAction(effectAction);
  }
  /**
   * @description Applies adjustment effect on an asset.
   * @param action
   * @return {this}
   */
  adjust(action) {
    return this.addAction(action);
  }
  /**
   * @description Rotates the asset by the given angle.
   * @param {RotateAction} rotateAction
   * @return {this}
   */
  rotate(rotateAction) {
    return this.addAction(rotateAction);
  }
  /**
   * @description Applies a pre-defined named transformation of the given name.
   * @param {NamedTransformation} namedTransformation
   * @return {this}
   */
  namedTransformation(namedTransformation) {
    return this.addAction(namedTransformation);
  }
  /**
   * @description Applies delivery action.
   * @param deliveryAction
   * @return {this}
   */
  delivery(deliveryAction) {
    return this.addAction(deliveryAction);
  }
  /**
   * @description Sets the color of the background.
   * @param {Qualifiers.Color} color
   * @return {this}
   */
  backgroundColor(color2) {
    return this.addAction(new BackgroundColor(prepareColor(color2)));
  }
  /**
   * @description Adds a layer in a Photoshop document.
   * @param action
   * @return {this}
   */
  psdTools(action) {
    return this.addAction(action);
  }
  /**
   * @description Extracts an image or a page using an index, a range, or a name from a layered media asset.
   * @param action
   * @return {this}
   */
  extract(action) {
    return this.addAction(action);
  }
  /**
   * @description Adds a flag as a separate action.
   * @param {Qualifiers.Flag | string} flagQualifier
   * @return {this}
   */
  addFlag(flagQualifier) {
    const action = new Action();
    let flagToAdd = flagQualifier;
    if (typeof flagQualifier === "string") {
      flagToAdd = new FlagQualifier(flagQualifier);
    }
    action.addQualifier(flagToAdd);
    return this.addAction(action);
  }
  /**
   * @description Inject a custom function into the image transformation pipeline.
   * @return {this}
   */
  customFunction(customFunction) {
    return this.addAction(customFunction);
  }
  /**
   * Transcodes the video (or audio) to another format.
   * @param {Action} action
   * @return {this}
   */
  transcode(action) {
    return this.addAction(action);
  }
  /**
   * Applies the specified video edit action.
   *
   * @param {videoEditType} action
   * @return {this}
   */
  videoEdit(action) {
    return this.addAction(action);
  }
  toJson() {
    const actions = [];
    for (const action of this.actions) {
      const json = action.toJson();
      if (isErrorObject(json)) {
        return json;
      }
      actions.push(json);
    }
    return { actions };
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/videoEdit/ConcatenateAction.js
var ConcatenateAction = class extends Action {
  /**
   *
   * @param {Qualifiers.Source.VideoSource | Qualifiers.Source.ImageSource | Qualifiers.Source.FetchSource} source
   *         the Source to concatenate
   */
  constructor(source2) {
    super();
    this._actionModel = {
      actionType: "concatenate",
      source: source2.toJson()
    };
    this.concatSource = source2;
  }
  /**
   * @description Sets the transition between a video and a concatenated source
   * @param {Qualifiers.Transition.VideoSource} source The source to concatenate.
   * @return {this}
   */
  transition(source2) {
    this._actionModel.transition = source2.toJson();
    this._transition = source2;
    return this;
  }
  /**
   * @description Prepend the concatenated video - Adds the video before the original
   * @return {this}
   */
  prepend() {
    this._actionModel.prepend = true;
    this._prepend = true;
    return this;
  }
  /**
   * The duration in seconds
   * @param {number} sec
   * @return {this}
   */
  duration(sec) {
    this._actionModel.duration = sec;
    this._duration = sec;
    return this;
  }
  /**
   * @description Get the transitionString for the toString() method
   * @return {string}
   */
  getTransitionString() {
    const transTx = this._transition.getTransformation();
    return [
      `e_transition,${this._transition.getOpenSourceString("l")}`,
      transTx && transTx.toString(),
      "fl_layer_apply"
    ].filter((a) => a).join("/");
  }
  /**
   * @description Get the string representation of the Concatenation action
   */
  toString() {
    const open = [
      this._duration && `du_${this._duration}`,
      !this._transition && `fl_splice`,
      `${this.concatSource.getOpenSourceString("l")}`
    ].filter((a) => a).join(",");
    const close = [
      "fl_layer_apply",
      this._prepend && "so_0"
    ].filter((a) => a).join(",");
    let concatSourceTx;
    if (this.concatSource.getTransformation()) {
      concatSourceTx = this.concatSource.getTransformation();
    } else {
      concatSourceTx = new Transformation();
    }
    if (this._transition) {
      concatSourceTx.addTransformation(this.getTransitionString());
    }
    return [
      open,
      concatSourceTx.toString(),
      close
    ].filter((a) => a).join("/");
  }
  static fromJson(actionModel, transformationFromJson) {
    const { source: source2, transition: transition2, prepend, duration } = actionModel;
    const sourceInstance = createSourceFromModel(source2, transformationFromJson);
    const result = new this(sourceInstance);
    if (transition2) {
      result.transition(VideoSource.fromJson(transition2, transformationFromJson));
    }
    if (prepend) {
      result.prepend();
    }
    if (duration) {
      result.duration(duration);
    }
    return result;
  }
};
var ConcatenateAction_default = ConcatenateAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/videoEdit/VolumeAction.js
var VolumeAction = class extends Action {
  constructor(volumeValue) {
    super();
    let volumeValueModel = { mode: "mute" };
    if (volumeValue !== "mute") {
      volumeValueModel = {
        mode: `${volumeValue}`.endsWith("db") ? "decibels" : "percent",
        value: +`${volumeValue}`.replace("db", "")
      };
    }
    this._actionModel = {
      actionType: "volume",
      volumeValue: volumeValueModel
    };
    const qualifierValue = new QualifierValue(["volume", volumeValue]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
  }
  static fromJson(actionModel) {
    const { volumeValue } = actionModel;
    const { mode: mode2 } = volumeValue;
    const value = mode2 === "mute" ? mode2 : volumeValue.value;
    const suffix = mode2 === "mute" || mode2 === "percent" ? "" : "db";
    return new this(`${value}${suffix}`);
  }
};
var VolumeAction_default = VolumeAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/videoEdit/PreviewAction.js
var PreviewAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {
      actionType: "preview"
    };
  }
  /**
   * @description Control the duration of the video segments
   * @param {string|number} minSegDuration The duration of a video segment
   * @return {this}
   */
  minimumSegmentDuration(minSegDuration) {
    this._actionModel.minimumSegmentDuration = +minSegDuration;
    this._minSeg = minSegDuration;
    return this;
  }
  /**
   * @description Control the number of the video segments
   * @param {string|number} maxSeg The number of the video segments.
   * @return {this}
   */
  maximumSegments(maxSeg) {
    this._actionModel.maximumSegments = +maxSeg;
    this._maxSeg = maxSeg;
    return this;
  }
  /**
   * @description control the length of the generated preview
   * @param {string|number} duration The duration in seconds such as 1.2, or 5.0
   * @return {this}
   */
  duration(duration) {
    this._actionModel.duration = +duration;
    this._duration = duration;
    return this;
  }
  toString() {
    return [
      "e_preview",
      this._duration && `duration_${toFloatAsString(this._duration)}`,
      this._maxSeg && `max_seg_${this._maxSeg}`,
      this._minSeg && `min_seg_dur_${toFloatAsString(this._minSeg)}`
    ].filter((a) => a).join(":");
  }
  static fromJson(actionModel) {
    const { duration, maximumSegments, minimumSegmentDuration } = actionModel;
    const result = new this();
    if (duration != null) {
      result.duration(duration);
    }
    if (maximumSegments != null) {
      result.maximumSegments(maximumSegments);
    }
    if (minimumSegmentDuration != null) {
      result.minimumSegmentDuration(minimumSegmentDuration);
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/videoEdit.js
function concatenate(source2) {
  return new ConcatenateAction_default(source2);
}
function trim() {
  return new TrimAction_default();
}
function volume(volumeValue) {
  return new VolumeAction_default(volumeValue);
}
function preview() {
  return new PreviewAction();
}
var VideoEdit = { concatenate, trim, volume, preview };

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/BitRateAction.js
var BitRateAction = class extends Action {
  constructor(bitRate2) {
    super();
    this.isConstant = false;
    this._actionModel = { actionType: "bitRate" };
    this.bitRate = bitRate2;
    this._actionModel.bitRate = bitRate2;
  }
  /**
   * @description video plays with a constant bitrate (CBR).
   */
  constant() {
    this.isConstant = true;
    this._actionModel.constant = true;
    return this;
  }
  prepareQualifiers() {
    let qualifierValue;
    if (this.isConstant) {
      qualifierValue = new QualifierValue([this.bitRate, "constant"]).setDelimiter(":");
    } else {
      qualifierValue = new QualifierValue(this.bitRate);
    }
    this.addQualifier(new Qualifier("br", qualifierValue));
    return this;
  }
  static fromJson(actionModel) {
    const { bitRate: bitRate2, constant } = actionModel;
    const result = new this(bitRate2);
    constant && result.constant();
    return result;
  }
};
var BitRateAction_default = BitRateAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/AudioCodecAction.js
var AudioCodecAction = class extends Action {
  constructor(codec) {
    super();
    this._actionModel = { actionType: "audioCodec" };
    this.addQualifier(new Qualifier("ac", codec));
    this._actionModel.audioCodec = codec;
  }
  static fromJson(actionModel) {
    const { audioCodec: audioCodec2 } = actionModel;
    const result = new this(audioCodec2);
    return result;
  }
};
var AudioCodecAction_default = AudioCodecAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/AudioFrequencyAction.js
var AudioFrequencyAction = class extends Action {
  constructor(freq) {
    super();
    this._actionModel = { actionType: "audioFrequency" };
    this.addQualifier(new Qualifier("af", freq));
    this._actionModel.audioFrequencyType = freq;
  }
  static fromJson(actionModel) {
    const { audioFrequencyType } = actionModel;
    const result = new this(audioFrequencyType.replace("freq", ""));
    return result;
  }
};
var AudioFrequencyAction_default = AudioFrequencyAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/FPSRangeAction.js
var FPSRangeAction = class extends Action {
  constructor(from, to) {
    super();
    this._actionModel = {};
    this.from = from;
    this._actionModel = {
      actionType: "fps",
      fps: { from }
    };
    if (to != null) {
      this.to = to;
      this._actionModel.fps.to = to;
    }
  }
  prepareQualifiers() {
    let qualifierValue;
    if (this.from && this.to) {
      qualifierValue = new QualifierValue(`${this.from}-${this.to}`);
    } else {
      qualifierValue = new QualifierValue(`${this.from}-`);
    }
    this.addQualifier(new Qualifier("fps", qualifierValue));
    return this;
  }
};
var FPSRangeAction_default = FPSRangeAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/FPSAction.js
var FPSAction = class extends Action {
  constructor(from) {
    super();
    this._actionModel = { actionType: "fps" };
    this._actionModel.fps = from;
    this.addQualifier(new Qualifier("fps", from));
  }
  static fromJson(actionModel) {
    const { fps: fps2 } = actionModel;
    let result;
    if (typeof fps2 === "object") {
      result = new FPSRangeAction_default(fps2.from, fps2.to);
    } else {
      result = new this(fps2);
    }
    return result;
  }
};
var FPSAction_default = FPSAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/KeyframeIntervalsAction.js
var KeyframeIntervalsAction = class extends Action {
  constructor(interval) {
    super();
    this._actionModel = { actionType: "keyframeInterval" };
    this._actionModel.interval = interval;
    this.addQualifier(new Qualifier("ki", toFloatAsString(interval)));
  }
  static fromJson(actionModel) {
    const { interval } = actionModel;
    const result = new this(interval);
    return result;
  }
};
var KeyframeIntervalsAction_default = KeyframeIntervalsAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/StreamingProfile.js
var StreamingProfileAction = class extends Action {
  constructor(profile) {
    super();
    this._actionModel = { actionType: "streamingProfile" };
    this.addQualifier(new Qualifier("sp", profile));
    this._actionModel.profile = STREAMING_PROFILE_TO_ACTION_TYPE_MAP[profile] || profile;
  }
  static fromJson(actionModel) {
    const { profile } = actionModel;
    const profileType = ACTION_TYPE_TO_STREAMING_PROFILE_MODE_MAP[profile] || profile;
    const result = new this(profileType);
    return result;
  }
};
var StreamingProfile_default = StreamingProfileAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/ToAnimatedAction.js
var ToAnimatedAction = class extends Action {
  constructor(animatedFormat = "") {
    super();
    this._actionModel = { actionType: "toAnimated" };
    if (animatedFormat.toString() === "webp") {
      this.addFlag(animatedWebP());
    }
    this.addFlag(animated());
    if (animatedFormat) {
      this.addQualifier(new Qualifier("f", animatedFormat));
    }
    this._actionModel.animatedFormat = animatedFormat;
  }
  /**
   * @description Sets the time between frames.
   * @param delayValue The time in milliseconds.
   */
  delay(delayValue) {
    this.addQualifier(new Qualifier("dl", delayValue));
    this._actionModel.delay = delayValue;
    return this;
  }
  /**
   * @description Sets the frequency at which the video is sampled.
   * @param sampling As a string (e.g. '2.3s'), samples one frame every 2.3 seconds.<br>As a number (e.g. 20),
   * samples that many equally spaced frames over the duration of the video.
   */
  sampling(sampling) {
    this.addQualifier(new Qualifier("vs", sampling));
    this._actionModel.sampling = sampling;
    return this;
  }
  static fromJson(actionModel) {
    const { animatedFormat, sampling, delay } = actionModel;
    const result = new this(animatedFormat);
    sampling && result.sampling(sampling);
    delay && result.delay(delay);
    return result;
  }
};
var ToAnimatedAction_default = ToAnimatedAction;

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/videoCodecType/VideoCodecType.js
var VideoCodecType = class extends Qualifier {
  constructor(type) {
    super("vc");
    this._type = type;
    this.addValue(type);
  }
  getType() {
    return this._type;
  }
};
var AdvVideoCodecType = class extends Qualifier {
  constructor(type) {
    super("vc");
    this._type = type;
  }
  getType() {
    return this._type;
  }
  /**
   * @description Specifies the profile to use with the h264 codec.
   * @param {Qualifiers.VideoCodecProfile | string} profile Sets the profile of the video codec
   * @example new AdvVideoCodecType('h264').profile(VideoCodecProfile.baseline())
   * @return this;
   */
  profile(profile) {
    this._prof = profile;
    return this;
  }
  getProfile() {
    return this._prof;
  }
  /**
   * @description Specifies the level to use with the h264 codec and specified profile.
   * @param {Qualifiers.VideoCodecLevel | number | string} lvl
   * @example new AdvVideoCodecType('h264').profile(VideoCodecLevel.baseline())
   * @return this;
   */
  level(lvl) {
    this._lvl = lvl;
    return this;
  }
  getLevel() {
    return this._lvl;
  }
  /**
   * @description returns a toString representation of this qualifier
   * @return string;
   */
  toString() {
    return `vc_${this._type}:${this._prof}:${this._lvl}`;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/videoCodec.js
function auto4() {
  return new VideoCodecType("auto");
}
function h264() {
  return new AdvVideoCodecType("h264");
}
function h265() {
  return new VideoCodecType("h265");
}
function proRes() {
  return new VideoCodecType("prores");
}
function theora() {
  return new VideoCodecType("theora");
}
function vp8() {
  return new VideoCodecType("vp8");
}
function vp9() {
  return new VideoCodecType("vp9");
}
var VIDEO_CODEC_TO_TRANSFORMATION = {
  "auto": auto4(),
  "h264": h264(),
  "h265": h265(),
  "prores": proRes(),
  "theora": theora(),
  "vp8": vp8(),
  "vp9": vp9()
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/VideoCodecAction.js
var VideoCodecAction = class extends Action {
  constructor(videoCodecTypeQualifier) {
    super();
    this._actionModel = { actionType: "videoCodec" };
    this._actionModel.videoCodec = { videoCodecName: videoCodecTypeQualifier.getType() };
    if (videoCodecTypeQualifier instanceof AdvVideoCodecType) {
      if (videoCodecTypeQualifier.getProfile()) {
        this._actionModel.videoCodec = Object.assign({ profile: videoCodecTypeQualifier.getProfile() }, this._actionModel.videoCodec);
      }
      if (videoCodecTypeQualifier.getLevel()) {
        this._actionModel.videoCodec = Object.assign({ level: videoCodecTypeQualifier.getLevel() }, this._actionModel.videoCodec);
      }
    }
    this.addQualifier(videoCodecTypeQualifier);
  }
  static fromJson(actionModel) {
    const { videoCodec: videoCodec2 } = actionModel;
    const result = new this(VIDEO_CODEC_TO_TRANSFORMATION[videoCodec2.videoCodecName]);
    videoCodec2.profile && new this(VIDEO_CODEC_TO_TRANSFORMATION[videoCodec2.videoCodecName].profile(videoCodec2.profile));
    videoCodec2.level && new this(VIDEO_CODEC_TO_TRANSFORMATION[videoCodec2.videoCodecName].level(videoCodec2.level));
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode.js
function audioFrequency(freq) {
  return new AudioFrequencyAction_default(freq);
}
function audioCodec(codec) {
  return new AudioCodecAction_default(codec);
}
function bitRate(bitRate2) {
  return new BitRateAction_default(bitRate2);
}
function fps(from) {
  return new FPSAction_default(from);
}
function fpsRange(from, to) {
  return new FPSRangeAction_default(from, to);
}
function keyframeInterval(interval) {
  return new KeyframeIntervalsAction_default(interval);
}
function streamingProfile(profile) {
  return new StreamingProfile_default(profile);
}
function toAnimated(animatedFormat = "") {
  return new ToAnimatedAction_default(animatedFormat);
}
function videoCodec(videoCodecType) {
  return new VideoCodecAction(videoCodecType);
}
var Transcode = { bitRate, audioCodec, audioFrequency, fps, fpsRange, keyframeInterval, streamingProfile, toAnimated, videoCodec };

// node_modules/@cloudinary/transformation-builder-sdk/actions/psdTools/ClipAction.js
var ClipAction = class extends Action {
  constructor() {
    super();
    this.isEvenOdd = false;
  }
  /**
   * @description The name of the path to clip by
   * @param {string} path
   * @return {this}
   */
  byName(path) {
    this.path = path;
    return this;
  }
  /**
   * @description The index of the path to clip by
   * @param {number} path
   * @return {this}
   */
  byIndex(path) {
    this.path = path;
    return this;
  }
  /**
   * @description Trims pixels according to a clipping path included in the original image using an evenodd clipping rule.
   * @return {this}
   */
  evenOdd() {
    this.isEvenOdd = true;
    return this;
  }
  prepareQualifiers() {
    let qualifierValue;
    if (typeof this.path === "string") {
      qualifierValue = new QualifierValue(["name", this.path]).setDelimiter(":");
    } else {
      qualifierValue = new QualifierValue(this.path);
    }
    if (this.isEvenOdd) {
      this.addFlag(clipEvenOdd());
    } else {
      this.addFlag(clip());
    }
    this.addQualifier(new Qualifier("pg", qualifierValue));
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/psdTools/GetLayerAction.js
var GetLayerAction = class extends Action {
  constructor() {
    super();
    this.qualifierValue = new QualifierValue();
    this.qualifierValue.delimiter = ";";
  }
  /**
   * @description deliver an image containing only specified layer of a Photoshop image from The layer index
   * @param {string|number} from the index of the layer
   */
  byIndex(from) {
    this.qualifierValue.addValue(from);
    return this;
  }
  /**
   * @description deliver an image containing only specified range of layers of a Photoshop image
   * @param {string|number} from The layer number
   * @param {string|number} to The layer number
   */
  byRange(from, to) {
    const range = new QualifierValue(from);
    range.addValue(to);
    range.delimiter = "-";
    this.qualifierValue.addValue(range);
    return this;
  }
  /**
   * @description deliver an image containing only specified layer by name of a Photoshop image
   * @param {string|number} name The layer by name
   */
  byName(name2) {
    this.name = name2;
    this.qualifierValue.addValue(name2);
    return this;
  }
  prepareQualifiers() {
    let qualifierValue = this.qualifierValue;
    if (this.name) {
      qualifierValue = new QualifierValue(["name", this.qualifierValue]).setDelimiter(":");
    }
    this.addQualifier(new Qualifier("pg", qualifierValue));
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/psdTools/SmartObjectAction.js
var SmartObjectAction = class extends Action {
  constructor() {
    super();
    this.qualifierValue = new QualifierValue();
    this.useName = false;
    this.qualifierValue.delimiter = ";";
  }
  /**
   * @description Creates a new instance using the specified number.
   * @param index The number.
   */
  byIndex(index) {
    this.smartObjectValue = index;
    this.qualifierValue.addValue(index);
    return this;
  }
  /**
   * @description Creates an instance using the name.
   * @param {string} layerName The name of the layer
   */
  byLayerName(layerName) {
    this.useName = true;
    this.qualifierValue.addValue(layerName);
    return this;
  }
  prepareQualifiers() {
    let qualifierValue;
    if (this.useName) {
      qualifierValue = new QualifierValue(["embedded:name", this.qualifierValue]);
    } else {
      qualifierValue = new QualifierValue(["embedded", this.qualifierValue]);
    }
    this.addQualifier(new Qualifier("pg", qualifierValue));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/psdTools.js
function clip2() {
  return new ClipAction();
}
function getLayer() {
  return new GetLayerAction();
}
function smartObject() {
  return new SmartObjectAction();
}
var PSDTools = { clip: clip2, getLayer, smartObject };

// node_modules/@cloudinary/transformation-builder-sdk/actions/animated.js
var AnimatedAction = class extends Action {
  constructor() {
    super();
  }
  /**
   * @description Controls the time delay between the frames of an animated image, in milliseconds.
   * @param {number} delayValue The delay in milliseconds
   * @return {this}
   */
  delay(delayValue) {
    this.addQualifier(new Qualifier("dl", delayValue));
    return this;
  }
  /**
   * @description Delivers an animated GIF that contains additional loops of the GIF.
   * @param {number} additionalLoops The additional number of times to play the animated GIF.
   * @return {this}
   */
  loop(additionalLoops) {
    const qualifierValue = new QualifierValue(["loop", additionalLoops]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
    return this;
  }
};
function edit() {
  return new AnimatedAction();
}
var Animated = {
  edit
};

export {
  Transformation,
  TextAlignment,
  StreamingProfile,
  SimulateColorBlind,
  RotationMode,
  Region,
  OutlineMode,
  ImproveMode,
  GradientDirection,
  FontHinting,
  Expression,
  Dither,
  Color,
  Background,
  AudioFrequency,
  AudioCodec,
  AspectRatio,
  ArtisticFilter,
  AnimatedFormat,
  ChromaSubSampling,
  Dpr,
  GradientFade,
  scale,
  imaggaScale,
  imaggaCrop,
  crop,
  fill2 as fill,
  fit,
  pad,
  limitFill,
  limitFit,
  minimumPad,
  minimumFit,
  fillPad,
  thumbnail,
  limitPad,
  Resize,
  Border,
  RoundCorners,
  Effect,
  Rotate,
  Adjust,
  Underlay,
  NamedTransformation,
  CustomFunction,
  VideoEdit,
  Transcode,
  PSDTools,
  Animated
};
//# sourceMappingURL=chunk-FVO633OL.js.map
