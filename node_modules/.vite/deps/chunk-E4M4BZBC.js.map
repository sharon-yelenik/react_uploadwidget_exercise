{
  "version": 3,
  "sources": ["../../@cloudinary/transformation-builder-sdk/qualifiers/blendMode/BlendModeQualifier.js", "../../@cloudinary/transformation-builder-sdk/internal/models/IImageSourceModel.js", "../../@cloudinary/transformation-builder-sdk/internal/models/IFetchSourceModel.js", "../../@cloudinary/transformation-builder-sdk/internal/models/ITextSourceModel.js", "../../@cloudinary/transformation-builder-sdk/internal/models/createSourceFromModel.js", "../../@cloudinary/transformation-builder-sdk/qualifiers/autoFocus.js", "../../@cloudinary/transformation-builder-sdk/qualifiers/gravity/qualifiers/compass/CompassQualifier.js", "../../@cloudinary/transformation-builder-sdk/internal/models/createGravityFromModel.js", "../../@cloudinary/transformation-builder-sdk/internal/models/createPositionFromModel.js", "../../@cloudinary/transformation-builder-sdk/qualifiers/video/TimelinePosition.js", "../../@cloudinary/transformation-builder-sdk/internal/models/createTimelinePositionFromModel.js", "../../@cloudinary/transformation-builder-sdk/actions/layer/LayerAction.js", "../../@cloudinary/transformation-builder-sdk/actions/overlay.js"],
  "sourcesContent": ["import { Action } from \"../../internal/Action.js\";\nimport { Qualifier } from \"../../internal/qualifier/Qualifier.js\";\nimport { QualifierValue } from \"../../internal/qualifier/QualifierValue.js\";\n/**\n * @description\n * Defines the mode of blending to use when overlaying an image.\n * Even though BlendMode is technically an actionQualifier, it implements exactly the same functionality as an action.\n * This is true because Position is actually compounded of multiple qualifiers\n *\n * <b>Learn more:</b> {@link https://cloudinary.com/documentation/effects_and_artistic_enhancements#blending_and_masking_layers|Overlay blending effects}\n *\n * @memberOf Qualifiers.BlendMode\n * @extends SDK.Action\n */\nclass BlendModeQualifier extends Action {\n    constructor(blendMode, level) {\n        super();\n        this.addQualifier(new Qualifier('e', new QualifierValue([blendMode, level])));\n    }\n}\nexport { BlendModeQualifier };\n", "/**\n * Validates that given obj is an IImageSourceModel\n * @param obj\n */\nexport function isIImageSourceModel(obj) {\n    return obj && obj.sourceType === 'image';\n}\n", "/**\n * Validates that given obj is an IFetchSourceModel\n * @param obj\n */\nexport function isIFetchSourceModel(obj) {\n    return obj && obj.sourceType === 'fetch';\n}\n", "/**\n * Validates that given obj is an IImageSourceModel\n * @param obj\n */\nexport function isITextSourceModel(obj) {\n    return obj && obj.sourceType === 'text';\n}\n", "import { isIImageSourceModel } from \"./IImageSourceModel.js\";\nimport { ImageSource } from \"../../qualifiers/source/sourceTypes/ImageSource.js\";\nimport { isIFetchSourceModel } from \"./IFetchSourceModel.js\";\nimport { FetchSource } from \"../../qualifiers/source/sourceTypes/FetchSource.js\";\nimport { VideoSource } from \"../../qualifiers/source/sourceTypes/VideoSource.js\";\nimport { isITextSourceModel } from \"./ITextSourceModel.js\";\nimport { TextSource } from \"../../qualifiers/source/sourceTypes/TextSource.js\";\n/**\n * Create Source from given model json\n * @param source\n * @param transformationFromJson\n */\nexport function createSourceFromModel(source, transformationFromJson) {\n    if (isITextSourceModel(source)) {\n        return TextSource.fromJson(source, transformationFromJson);\n    }\n    else if (isIImageSourceModel(source)) {\n        return ImageSource.fromJson(source, transformationFromJson);\n    }\n    else if (isIFetchSourceModel(source)) {\n        return FetchSource.fromJson(source, transformationFromJson);\n    }\n    else {\n        return VideoSource.fromJson(source, transformationFromJson);\n    }\n}\n", "import { QualifierValue } from \"../internal/qualifier/QualifierValue.js\";\n/**\n * @summary qualifier\n * @namespace AutoFocus\n * @memberOf Qualifiers\n * @see Visit {@link Qualifiers.Gravity|Gravity} for an example\n */\n/**\n * @memberOf Qualifiers.AutoFocus\n * @extends {SDK.QualifierValue}\n * @see Visit {@link Qualifiers.Gravity|Gravity} for an example\n */\nclass AutoFocus extends QualifierValue {\n    constructor(focusOn, weight) {\n        super();\n        this._weight = weight;\n        this.focusOn = focusOn;\n        this.shouldAvoid = false;\n    }\n    /**\n     * @summary qualifier\n     * @description Specifies the object to focus on automatically\n     * Accepts an AutoFocusObject (which is just a wrapper for a FocusOn object, but with extra method: avoid, weight)\n     * @param {Qualifiers.FocusOn} obj The object to focus on.\n     * @param {number} weight\n     */\n    static focusOn(obj, weight) {\n        return new AutoFocus(obj, weight);\n    }\n    shouldAddWeight() {\n        return typeof this._weight === 'number' || typeof this._weight === 'string' || this.shouldAvoid;\n    }\n    /**\n     * @summary qualifier\n     * @desc Get the name of the of the object\n     */\n    getName() {\n        return this.focusOn.name;\n    }\n    /**\n     * @summary qualifier\n     * @desc Get the weight for the object\n     */\n    getWeight() {\n        if (this.shouldAvoid) {\n            return 'avoid';\n        }\n        else {\n            return this._weight;\n        }\n    }\n    /**\n     * @summary qualifier\n     * @desc Return the string representation of this QualifierValue\n     */\n    toString() {\n        // Future proofing, in case we'd like to support some custom string in the future, or if data is coming from a DB\n        if (this.shouldAddWeight()) {\n            return `${this.getName()}_${this.getWeight()}`;\n        }\n        else {\n            return `${this.getName()}`;\n        }\n    }\n    /**\n     * @summary qualifier\n     * @description Sets the importance level of the object within the automatic gravity algorithm\n     * @param {numebr} w The focus weight for the object\n     * @return {this}\n     */\n    weight(w) {\n        this._weight = w;\n        return this;\n    }\n    /**\n     * @summary qualifier\n     * @description Attempts to avoid the detected object in the image\n     * @return {this}\n     */\n    avoid() {\n        this.shouldAvoid = true;\n        return this;\n    }\n}\nconst focusOn = AutoFocus.focusOn;\nexport { AutoFocus, focusOn };\n", "import { QualifierValue } from \"../../../../internal/qualifier/QualifierValue.js\";\n/**\n * @memberOf Qualifiers.Compass\n * @extends {SDK.QualifierValue}\n */\nclass CompassQualifier extends QualifierValue {\n    constructor(val) {\n        super();\n        this.val = val;\n    }\n    toString() {\n        return this.val;\n    }\n}\nexport { CompassQualifier };\n", "import { autoGravity, focusOn } from \"../../qualifiers/gravity.js\";\nimport { FocusOnValue, ocr } from \"../../qualifiers/focusOn.js\";\nimport { AutoFocus } from \"../../qualifiers/autoFocus.js\";\nimport { CompassGravity } from \"../../qualifiers/gravity/compassGravity/CompassGravity.js\";\nimport { CompassQualifier } from \"../../qualifiers/gravity/qualifiers/compass/CompassQualifier.js\";\n/**\n * Validates that gravityModel is an ICompassGravityModel\n * @param gravityModel\n */\nfunction isCompassGravityModel(gravityModel) {\n    return gravityModel.gravityType === 'direction';\n}\n/**\n * Validates that gravityModel is an IOcrGravityModel\n * @param gravityModel\n */\nfunction isOcrGravityModel(gravityModel) {\n    return gravityModel.gravityType === 'ocr';\n}\n/**\n * Validates that gravityModel is an IAutoGravityModel\n * @param gravityModel\n */\nfunction isAutoGravityModel(gravityModel) {\n    return gravityModel.gravityType === 'auto';\n}\n/**\n * Create AutoFocus from IAutoGravityObjectModel\n * @param autoGravityObjectModel\n */\nfunction createAutoFocusFromModel(autoGravityObjectModel) {\n    const { object, weight, avoid } = autoGravityObjectModel;\n    const autoFocus = new AutoFocus(new FocusOnValue(object));\n    (weight || weight === 0) && autoFocus.weight(weight);\n    avoid && autoFocus.avoid();\n    return autoFocus;\n}\n/**\n * Create AutoGravity from IAutoGravityModel\n * @param gravityModel\n */\nfunction createAutoGravityFromModel(gravityModel) {\n    const autoFocusModel = gravityModel.autoFocus || [];\n    const autoFocus = autoFocusModel.map(createAutoFocusFromModel);\n    return autoGravity().autoFocus(...autoFocus);\n}\n/**\n * Create FocusOnGravity from given IFocusOnGravityModel\n * @param gravityModel\n */\nfunction createFocusOnGravityFromModel(gravityModel) {\n    const focusOnObjects = (gravityModel.focusOnObjects || []).map((str) => new FocusOnValue(str));\n    const result = focusOn(...focusOnObjects);\n    if (gravityModel.fallbackGravity) {\n        const autoGravity = createAutoGravityFromModel(gravityModel.fallbackGravity);\n        result.fallbackGravity(autoGravity);\n    }\n    return result;\n}\n/**\n * Create gravity instance from given gravity model\n * @param gravityModel\n */\nfunction createGravityFromModel(gravityModel) {\n    if (isCompassGravityModel(gravityModel)) {\n        return new CompassGravity(new CompassQualifier(gravityModel.compass));\n    }\n    if (isOcrGravityModel(gravityModel)) {\n        return focusOn(ocr());\n    }\n    if (isAutoGravityModel(gravityModel)) {\n        return createAutoGravityFromModel(gravityModel);\n    }\n    return createFocusOnGravityFromModel(gravityModel);\n}\nexport { createGravityFromModel };\n", "import { Position } from \"../../qualifiers/position.js\";\nimport { createGravityFromModel } from \"./createGravityFromModel.js\";\n/**\n * Create Position from given IPositionModel\n * @param position\n */\nexport function createPositionFromModel(position) {\n    const { offsetX, offsetY, tiled, allowOverflow, gravity } = position;\n    const result = new Position();\n    if (offsetX) {\n        result.offsetX(offsetX);\n    }\n    if (offsetY) {\n        result.offsetY(offsetY);\n    }\n    if (tiled) {\n        result.tiled();\n    }\n    if (allowOverflow != null) {\n        result.allowOverflow(allowOverflow);\n    }\n    if (gravity) {\n        result.gravity(createGravityFromModel(gravity));\n    }\n    return result;\n}\n", "import { Action } from \"../../internal/Action.js\";\nimport { Qualifier } from \"../../internal/qualifier/Qualifier.js\";\n/**\n * @description Defines a video range using startOffset, endOffset, duration.\n * @namespace TimelinePosition\n * @memberOf Qualifiers\n */\n/**\n * TimelinePosition\n * @memberOf Qualifiers.TimelinePosition\n */\nclass TimelinePosition extends Action {\n    constructor() {\n        super();\n        this._actionModel = {};\n    }\n    /**\n     * @param {string | number} startOffset\n     */\n    startOffset(startOffset) {\n        const startOffsetQualifier = new Qualifier('so', startOffset);\n        this.addQualifier(startOffsetQualifier);\n        this._actionModel.startOffset = startOffsetQualifier.qualifierValue.toString();\n        return this;\n    }\n    /**\n     * @param {string | number} endOffset\n     */\n    endOffset(endOffset) {\n        const endOffsetQualifier = new Qualifier('eo', endOffset);\n        this.addQualifier(endOffsetQualifier);\n        this._actionModel.endOffset = endOffsetQualifier.qualifierValue.toString();\n        return this;\n    }\n    /**\n     * @param {string | number} duration\n     */\n    duration(duration) {\n        const durationQualifier = new Qualifier('du', duration);\n        this.addQualifier(durationQualifier);\n        this._actionModel.duration = durationQualifier.qualifierValue.toString();\n        return this;\n    }\n}\nexport { TimelinePosition };\n", "import { TimelinePosition } from \"../../qualifiers/video/TimelinePosition.js\";\n/**\n * Create TimelinePosition from given ITimelinePositionModel\n * @param timelinePosition\n */\nexport function createTimelinePositionFromModel(timelinePosition) {\n    const { startOffset, endOffset, duration } = timelinePosition;\n    const result = new TimelinePosition();\n    if (startOffset) {\n        result.startOffset(startOffset);\n    }\n    if (endOffset) {\n        result.endOffset(endOffset);\n    }\n    if (duration) {\n        result.duration(duration);\n    }\n    return result;\n}\n", "import { Action } from \"../../internal/Action.js\";\nimport { BlendModeQualifier } from \"../../qualifiers/blendMode/BlendModeQualifier.js\";\nimport { FlagQualifier } from \"../../qualifiers/flag/FlagQualifier.js\";\nimport { Qualifier } from \"../../internal/qualifier/Qualifier.js\";\nimport { createSourceFromModel } from \"../../internal/models/createSourceFromModel.js\";\nimport { createPositionFromModel } from \"../../internal/models/createPositionFromModel.js\";\nimport { createTimelinePositionFromModel } from \"../../internal/models/createTimelinePositionFromModel.js\";\nimport { ACTION_TYPE_TO_BLEND_MODE_MAP } from \"../../internal/internalConstants.js\";\n/**\n * @extends SDK.Action\n * @memberOf SDK\n * @description\n * A generic Layer action that can add a Video, Text or Image layer.<br>\n * This class can represent an overlay or an underlay.\n */\nclass LayerAction extends Action {\n    /**\n     * @description Creates a LayerAction to be used with overlays and underlays\n     * @param {ImageSource | TextSource | VideoSource} layerSource The Source used for the layer, use the builders provided {@link Qualifiers.Source|here}\n     */\n    constructor(layerSource) {\n        super();\n        this.source = layerSource;\n        this._actionModel = {\n            actionType: 'overlay',\n            source: layerSource.toJson()\n        };\n    }\n    /**\n     * @description Sets the layerType to 'u' (underlay) or 'l' (overlay).\n     * @param {'u' | 'l'} type\n     * @return {this}\n     */\n    setLayerType(type) {\n        this.layerType = type;\n        this._actionModel.actionType = type === 'u' ? 'underlay' : 'overlay';\n        return this;\n    }\n    /**\n     * @description Sets the timeline position of the video layer\n     * @param {Qualifiers.TimelinePosition} timelinePosition\n     * @return {this}\n     */\n    timeline(timelinePosition) {\n        this._timelinePosition = timelinePosition;\n        this._actionModel.timelinePosition = timelinePosition.toJson();\n        return this;\n    }\n    /**\n     * @description Sets the position of the layer\n     * @param {Qualifiers.Position} position\n     * @return {this}\n     */\n    position(position) {\n        this._position = position;\n        this._actionModel.position = position.toJson();\n        return this;\n    }\n    /**\n     * @description Specifies how to blend the image overlay with the base overlay\n     * @param {Qualifiers.BlendMode|BlendModeType} blendMode\n     * @return {this}\n     */\n    blendMode(blendMode) {\n        this._blendMode = blendMode;\n        const [mode, level] = `${blendMode}`.replace('e_', '').split(\":\");\n        if (mode === 'anti_removal') {\n            this._actionModel.blendMode = level ? { blendModeType: 'antiRemoval', level: level } : { blendModeType: 'antiRemoval' };\n        }\n        else {\n            this._actionModel.blendMode = { blendModeType: mode };\n        }\n        return this;\n    }\n    /**\n     * @private\n     * @description\n     * Closes a layer (layers are built in three stages -> /Open/Transform/Close).\n     * @return {SDK.Action}\n     */\n    closeLayer() {\n        var _a, _b, _c, _d;\n        const bit = new Action().addFlag(new FlagQualifier('layer_apply'));\n        (_a = this._position) === null || _a === void 0 ? void 0 : _a.qualifiers.forEach((qualifier) => {\n            bit.addQualifier(qualifier);\n        });\n        // Flags are stored separately from qualifiers, we need to add those as well\n        (_b = this._position) === null || _b === void 0 ? void 0 : _b.flags.forEach((flag) => {\n            bit.addFlag(flag);\n        });\n        if (typeof this._blendMode === \"string\") {\n            bit.addQualifier(new Qualifier('e', this._blendMode));\n        }\n        else {\n            (_c = this._blendMode) === null || _c === void 0 ? void 0 : _c.qualifiers.forEach((qualifier) => {\n                bit.addQualifier(qualifier);\n            });\n        }\n        (_d = this._timelinePosition) === null || _d === void 0 ? void 0 : _d.qualifiers.forEach((qualifier) => {\n            bit.addQualifier(qualifier);\n        });\n        return bit;\n    }\n    /**\n     * @private\n     * @description\n     * Opens a layer (layers are built in three stages -> /Open/Transform/Close).\n     * @return string\n     */\n    openLayer() {\n        return `${this.source.getOpenSourceString(this.layerType)}`;\n    }\n    /**\n     * @description\n     * Serializes the Layer to a string\n     * @return {string}\n     */\n    toString() {\n        return [\n            this.openLayer(),\n            this.source.getTransformation() && this.source.getTransformation().toString(),\n            this.closeLayer()\n        ].filter((a) => a).join('/');\n    }\n    static fromJson(actionModel, transformationFromJson) {\n        const { source, actionType, position, timelinePosition, blendMode } = actionModel;\n        const sourceInstance = createSourceFromModel(source, transformationFromJson);\n        // We are using this() to allow inheriting classes to use super.fromJson.apply(this, [actionModel])\n        // This allows the inheriting classes to determine the class to be created\n        const result = new this(sourceInstance);\n        const layerType = actionType === 'overlay' ? 'l' : 'u';\n        result.setLayerType(layerType);\n        if (position) {\n            result.position(createPositionFromModel(position));\n        }\n        if (timelinePosition) {\n            result.timeline(createTimelinePositionFromModel(timelinePosition));\n        }\n        if (blendMode) {\n            const blendModeType = ACTION_TYPE_TO_BLEND_MODE_MAP[blendMode.blendModeType] || blendMode.blendModeType;\n            if (blendMode === null || blendMode === void 0 ? void 0 : blendMode.level) {\n                result.blendMode(new BlendModeQualifier(blendModeType, blendMode.level));\n            }\n            else {\n                result.blendMode(new BlendModeQualifier(blendModeType));\n            }\n        }\n        return result;\n    }\n}\nexport { LayerAction };\n", "import { LayerAction } from \"./layer/LayerAction.js\";\n/**\n * @description Adds a video, text or an image layer as an overlay over the base layer. </br>\n * @memberOf Actions\n * @namespace Overlay\n * @see Visit {@link Qualifiers.TextStyle|TextStyle} for advanced text options\n * @see {@link Actions.Underlay| The underlay action}\n * @example\n * import {Cloudinary} from \"@cloudinary/url-gen\";\n *\n * const yourCldInstance = new Cloudinary({cloud:{cloudName:'demo'}});\n * const myVideo = yourCldInstance.video('dog');\n *\n * import {source} from \"@cloudinary/url-gen/actions/overlay\"\n * import {image, video, text} from \"@cloudinary/url-gen/qualifiers/source\"\n * import {TextStyle} from '@cloudinary/url-gen/qualifiers/textStyle\n *\n * myVideo.overlay(\n *       source(image('myImage'))\n *     )\n *\n * myVideo.overlay(\n *       source(video('myVideo'))\n *     )\n *\n * myVideo.overlay(\n *       source(text('My text'), 'arial_15')\n *     )\n *\n * // Or a text with more complex options\n * myVideo.overlay(\n *       source(text('My text'), new TextStyle('arial', 50))\n *     )\n */\n/**\n * @summary action\n * @memberOf Actions.Overlay\n * @description Adds a layer for an asset\n * @param {Qualifiers.Source.ImageSource | Qualifiers.Source.TextSource | Qualifiers.Source.VideoSource} source\n *        The Source used for the layer, use the functions provided {@link Qualifiers.Source|here} to easily create these objects\n * @return {SDK.LayerAction}\n */\nfunction source(source) {\n    return new LayerAction(source)\n        .setLayerType('l');\n}\nconst Overlay = { source };\nexport { Overlay, source };\n"],
  "mappings": "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",
  "names": ["source", "focusOn", "autoGravity", "source", "source"]
}
