import {
  PositionQualifier
} from "./chunk-LI44QUJM.js";
import {
  FocusOnValue,
  ocr
} from "./chunk-2XNLFFNL.js";
import {
  ACTION_TYPE_TO_BLEND_MODE_MAP
} from "./chunk-DOI2HF4F.js";
import {
  FetchSource,
  ImageSource,
  TextSource,
  VideoSource
} from "./chunk-B43TY7UJ.js";
import {
  Action,
  FlagQualifier
} from "./chunk-4UABOL5W.js";
import {
  CompassGravity,
  autoGravity,
  focusOn
} from "./chunk-LFEWX2TB.js";
import {
  Qualifier
} from "./chunk-UHKTWXPV.js";
import {
  QualifierValue
} from "./chunk-QESUYXYX.js";

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/blendMode/BlendModeQualifier.js
var BlendModeQualifier = class extends Action {
  constructor(blendMode, level) {
    super();
    this.addQualifier(new Qualifier("e", new QualifierValue([blendMode, level])));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/IImageSourceModel.js
function isIImageSourceModel(obj) {
  return obj && obj.sourceType === "image";
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/IFetchSourceModel.js
function isIFetchSourceModel(obj) {
  return obj && obj.sourceType === "fetch";
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/ITextSourceModel.js
function isITextSourceModel(obj) {
  return obj && obj.sourceType === "text";
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createSourceFromModel.js
function createSourceFromModel(source2, transformationFromJson) {
  if (isITextSourceModel(source2)) {
    return TextSource.fromJson(source2, transformationFromJson);
  } else if (isIImageSourceModel(source2)) {
    return ImageSource.fromJson(source2, transformationFromJson);
  } else if (isIFetchSourceModel(source2)) {
    return FetchSource.fromJson(source2, transformationFromJson);
  } else {
    return VideoSource.fromJson(source2, transformationFromJson);
  }
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/autoFocus.js
var AutoFocus = class extends QualifierValue {
  constructor(focusOn3, weight) {
    super();
    this._weight = weight;
    this.focusOn = focusOn3;
    this.shouldAvoid = false;
  }
  /**
   * @summary qualifier
   * @description Specifies the object to focus on automatically
   * Accepts an AutoFocusObject (which is just a wrapper for a FocusOn object, but with extra method: avoid, weight)
   * @param {Qualifiers.FocusOn} obj The object to focus on.
   * @param {number} weight
   */
  static focusOn(obj, weight) {
    return new AutoFocus(obj, weight);
  }
  shouldAddWeight() {
    return typeof this._weight === "number" || typeof this._weight === "string" || this.shouldAvoid;
  }
  /**
   * @summary qualifier
   * @desc Get the name of the of the object
   */
  getName() {
    return this.focusOn.name;
  }
  /**
   * @summary qualifier
   * @desc Get the weight for the object
   */
  getWeight() {
    if (this.shouldAvoid) {
      return "avoid";
    } else {
      return this._weight;
    }
  }
  /**
   * @summary qualifier
   * @desc Return the string representation of this QualifierValue
   */
  toString() {
    if (this.shouldAddWeight()) {
      return `${this.getName()}_${this.getWeight()}`;
    } else {
      return `${this.getName()}`;
    }
  }
  /**
   * @summary qualifier
   * @description Sets the importance level of the object within the automatic gravity algorithm
   * @param {numebr} w The focus weight for the object
   * @return {this}
   */
  weight(w) {
    this._weight = w;
    return this;
  }
  /**
   * @summary qualifier
   * @description Attempts to avoid the detected object in the image
   * @return {this}
   */
  avoid() {
    this.shouldAvoid = true;
    return this;
  }
};
var focusOn2 = AutoFocus.focusOn;

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/gravity/qualifiers/compass/CompassQualifier.js
var CompassQualifier = class extends QualifierValue {
  constructor(val) {
    super();
    this.val = val;
  }
  toString() {
    return this.val;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createGravityFromModel.js
function isCompassGravityModel(gravityModel) {
  return gravityModel.gravityType === "direction";
}
function isOcrGravityModel(gravityModel) {
  return gravityModel.gravityType === "ocr";
}
function isAutoGravityModel(gravityModel) {
  return gravityModel.gravityType === "auto";
}
function createAutoFocusFromModel(autoGravityObjectModel) {
  const { object, weight, avoid } = autoGravityObjectModel;
  const autoFocus = new AutoFocus(new FocusOnValue(object));
  (weight || weight === 0) && autoFocus.weight(weight);
  avoid && autoFocus.avoid();
  return autoFocus;
}
function createAutoGravityFromModel(gravityModel) {
  const autoFocusModel = gravityModel.autoFocus || [];
  const autoFocus = autoFocusModel.map(createAutoFocusFromModel);
  return autoGravity().autoFocus(...autoFocus);
}
function createFocusOnGravityFromModel(gravityModel) {
  const focusOnObjects = (gravityModel.focusOnObjects || []).map((str) => new FocusOnValue(str));
  const result = focusOn(...focusOnObjects);
  if (gravityModel.fallbackGravity) {
    const autoGravity2 = createAutoGravityFromModel(gravityModel.fallbackGravity);
    result.fallbackGravity(autoGravity2);
  }
  return result;
}
function createGravityFromModel(gravityModel) {
  if (isCompassGravityModel(gravityModel)) {
    return new CompassGravity(new CompassQualifier(gravityModel.compass));
  }
  if (isOcrGravityModel(gravityModel)) {
    return focusOn(ocr());
  }
  if (isAutoGravityModel(gravityModel)) {
    return createAutoGravityFromModel(gravityModel);
  }
  return createFocusOnGravityFromModel(gravityModel);
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createPositionFromModel.js
function createPositionFromModel(position) {
  const { offsetX, offsetY, tiled, allowOverflow, gravity } = position;
  const result = new PositionQualifier();
  if (offsetX) {
    result.offsetX(offsetX);
  }
  if (offsetY) {
    result.offsetY(offsetY);
  }
  if (tiled) {
    result.tiled();
  }
  if (allowOverflow != null) {
    result.allowOverflow(allowOverflow);
  }
  if (gravity) {
    result.gravity(createGravityFromModel(gravity));
  }
  return result;
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/video/TimelinePosition.js
var TimelinePosition = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
  }
  /**
   * @param {string | number} startOffset
   */
  startOffset(startOffset) {
    const startOffsetQualifier = new Qualifier("so", startOffset);
    this.addQualifier(startOffsetQualifier);
    this._actionModel.startOffset = startOffsetQualifier.qualifierValue.toString();
    return this;
  }
  /**
   * @param {string | number} endOffset
   */
  endOffset(endOffset) {
    const endOffsetQualifier = new Qualifier("eo", endOffset);
    this.addQualifier(endOffsetQualifier);
    this._actionModel.endOffset = endOffsetQualifier.qualifierValue.toString();
    return this;
  }
  /**
   * @param {string | number} duration
   */
  duration(duration) {
    const durationQualifier = new Qualifier("du", duration);
    this.addQualifier(durationQualifier);
    this._actionModel.duration = durationQualifier.qualifierValue.toString();
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createTimelinePositionFromModel.js
function createTimelinePositionFromModel(timelinePosition) {
  const { startOffset, endOffset, duration } = timelinePosition;
  const result = new TimelinePosition();
  if (startOffset) {
    result.startOffset(startOffset);
  }
  if (endOffset) {
    result.endOffset(endOffset);
  }
  if (duration) {
    result.duration(duration);
  }
  return result;
}

// node_modules/@cloudinary/transformation-builder-sdk/actions/layer/LayerAction.js
var LayerAction = class extends Action {
  /**
   * @description Creates a LayerAction to be used with overlays and underlays
   * @param {ImageSource | TextSource | VideoSource} layerSource The Source used for the layer, use the builders provided {@link Qualifiers.Source|here}
   */
  constructor(layerSource) {
    super();
    this.source = layerSource;
    this._actionModel = {
      actionType: "overlay",
      source: layerSource.toJson()
    };
  }
  /**
   * @description Sets the layerType to 'u' (underlay) or 'l' (overlay).
   * @param {'u' | 'l'} type
   * @return {this}
   */
  setLayerType(type) {
    this.layerType = type;
    this._actionModel.actionType = type === "u" ? "underlay" : "overlay";
    return this;
  }
  /**
   * @description Sets the timeline position of the video layer
   * @param {Qualifiers.TimelinePosition} timelinePosition
   * @return {this}
   */
  timeline(timelinePosition) {
    this._timelinePosition = timelinePosition;
    this._actionModel.timelinePosition = timelinePosition.toJson();
    return this;
  }
  /**
   * @description Sets the position of the layer
   * @param {Qualifiers.Position} position
   * @return {this}
   */
  position(position) {
    this._position = position;
    this._actionModel.position = position.toJson();
    return this;
  }
  /**
   * @description Specifies how to blend the image overlay with the base overlay
   * @param {Qualifiers.BlendMode|BlendModeType} blendMode
   * @return {this}
   */
  blendMode(blendMode) {
    this._blendMode = blendMode;
    const [mode, level] = `${blendMode}`.replace("e_", "").split(":");
    if (mode === "anti_removal") {
      this._actionModel.blendMode = level ? { blendModeType: "antiRemoval", level } : { blendModeType: "antiRemoval" };
    } else {
      this._actionModel.blendMode = { blendModeType: mode };
    }
    return this;
  }
  /**
   * @private
   * @description
   * Closes a layer (layers are built in three stages -> /Open/Transform/Close).
   * @return {SDK.Action}
   */
  closeLayer() {
    var _a, _b, _c, _d;
    const bit = new Action().addFlag(new FlagQualifier("layer_apply"));
    (_a = this._position) === null || _a === void 0 ? void 0 : _a.qualifiers.forEach((qualifier) => {
      bit.addQualifier(qualifier);
    });
    (_b = this._position) === null || _b === void 0 ? void 0 : _b.flags.forEach((flag) => {
      bit.addFlag(flag);
    });
    if (typeof this._blendMode === "string") {
      bit.addQualifier(new Qualifier("e", this._blendMode));
    } else {
      (_c = this._blendMode) === null || _c === void 0 ? void 0 : _c.qualifiers.forEach((qualifier) => {
        bit.addQualifier(qualifier);
      });
    }
    (_d = this._timelinePosition) === null || _d === void 0 ? void 0 : _d.qualifiers.forEach((qualifier) => {
      bit.addQualifier(qualifier);
    });
    return bit;
  }
  /**
   * @private
   * @description
   * Opens a layer (layers are built in three stages -> /Open/Transform/Close).
   * @return string
   */
  openLayer() {
    return `${this.source.getOpenSourceString(this.layerType)}`;
  }
  /**
   * @description
   * Serializes the Layer to a string
   * @return {string}
   */
  toString() {
    return [
      this.openLayer(),
      this.source.getTransformation() && this.source.getTransformation().toString(),
      this.closeLayer()
    ].filter((a) => a).join("/");
  }
  static fromJson(actionModel, transformationFromJson) {
    const { source: source2, actionType, position, timelinePosition, blendMode } = actionModel;
    const sourceInstance = createSourceFromModel(source2, transformationFromJson);
    const result = new this(sourceInstance);
    const layerType = actionType === "overlay" ? "l" : "u";
    result.setLayerType(layerType);
    if (position) {
      result.position(createPositionFromModel(position));
    }
    if (timelinePosition) {
      result.timeline(createTimelinePositionFromModel(timelinePosition));
    }
    if (blendMode) {
      const blendModeType = ACTION_TYPE_TO_BLEND_MODE_MAP[blendMode.blendModeType] || blendMode.blendModeType;
      if (blendMode === null || blendMode === void 0 ? void 0 : blendMode.level) {
        result.blendMode(new BlendModeQualifier(blendModeType, blendMode.level));
      } else {
        result.blendMode(new BlendModeQualifier(blendModeType));
      }
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/overlay.js
function source(source2) {
  return new LayerAction(source2).setLayerType("l");
}
var Overlay = { source };

export {
  createGravityFromModel,
  createSourceFromModel,
  LayerAction,
  source,
  Overlay
};
//# sourceMappingURL=chunk-E4M4BZBC.js.map
