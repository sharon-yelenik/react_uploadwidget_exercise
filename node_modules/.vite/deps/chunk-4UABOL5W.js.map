{
  "version": 3,
  "sources": ["../../@cloudinary/transformation-builder-sdk/qualifiers/flag/FlagQualifier.js", "../../@cloudinary/transformation-builder-sdk/internal/utils/dataStructureUtils.js", "../../@cloudinary/transformation-builder-sdk/internal/models/actionToJson.js", "../../@cloudinary/transformation-builder-sdk/internal/models/ActionModel.js", "../../@cloudinary/transformation-builder-sdk/internal/Action.js"],
  "sourcesContent": ["import { QualifierValue } from \"../../internal/qualifier/QualifierValue.js\";\nimport { Qualifier } from \"../../internal/qualifier/Qualifier.js\";\n/**\n * @memberOf Qualifiers.Flag\n * @extends {SDK.Qualifier}\n * @description the FlagQualifier class\n */\nclass FlagQualifier extends Qualifier {\n    constructor(flagType, flagValue) {\n        let qualifierValue;\n        if (flagValue) {\n            qualifierValue = new QualifierValue([flagType, `${flagValue}`]).setDelimiter(':');\n        }\n        else {\n            qualifierValue = flagType;\n        }\n        super('fl', qualifierValue);\n        this.flagValue = flagValue;\n    }\n    toString() {\n        return super.toString().replace(/\\./, '%2E');\n    }\n    getFlagValue() {\n        return this.flagValue;\n    }\n}\nexport { FlagQualifier };\n", "/**\n * Sort a map by key\n * @private\n * @param map <string, any>\n * @Return array of map's values sorted by key\n */\nfunction mapToSortedArray(map, flags) {\n    const array = Array.from(map.entries());\n    // objects from the Array.from() method above are stored in array of arrays:\n    // [[qualifierKey, QualifierObj], [qualifierKey, QualifierObj]]\n    // Flags is an array of FlagQualifierObj\n    // We need to convert it to the same form: [flagQualifier] =>  ['fl', flagQualifier]\n    flags.forEach((flag) => {\n        array.push(['fl', flag]); // push ['fl', flagQualifier]\n    });\n    return array.sort().map((v) => v[1]);\n}\n/**\n * Checks if `value` is a string.\n * @private\n * @param {*} value The value to check.\n * @return {boolean} `true` if `value` is a string, else `false`.\n */\nfunction isString(value) {\n    return (typeof value === 'string' || value instanceof String);\n}\nexport { isString, mapToSortedArray };\n", "import { createUnsupportedError } from \"../utils/unsupportedError.js\";\n/**\n * Returns the action's model\n */\nexport function actionToJson() {\n    var _a, _b, _c;\n    const actionModelIsNotEmpty = this._actionModel && Object.keys(this._actionModel).length;\n    const sourceTransformationError = (_c = (_b = (_a = this._actionModel) === null || _a === void 0 ? void 0 : _a.source) === null || _b === void 0 ? void 0 : _b.transformation) === null || _c === void 0 ? void 0 : _c.error;\n    // Should return error when there is unsupported transformation inside\n    if (sourceTransformationError && sourceTransformationError instanceof Error) {\n        return { error: sourceTransformationError };\n    }\n    if (actionModelIsNotEmpty) {\n        return this._actionModel;\n    }\n    return { error: createUnsupportedError(`unsupported action ${this.constructor.name}`) };\n}\n", "import { actionToJson } from \"./actionToJson.js\";\nexport class ActionModel {\n    constructor() {\n        this._actionModel = {};\n    }\n    toJson() {\n        return actionToJson.apply(this);\n    }\n}\n", "import { FlagQualifier } from \"../qualifiers/flag/FlagQualifier.js\";\nimport { Qualifier } from \"./qualifier/Qualifier.js\";\nimport { mapToSortedArray } from \"./utils/dataStructureUtils.js\";\nimport { ActionModel } from \"./models/ActionModel.js\";\n/**\n * @summary SDK\n * @memberOf SDK\n * @description Defines the category of transformation to perform.\n */\nclass Action extends ActionModel {\n    constructor() {\n        super(...arguments);\n        // We're using map, to overwrite existing keys. for example:\n        // addParam(w_100).addQualifier(w_200) should result in w_200. and not w_100,w_200\n        this.qualifiers = new Map();\n        // Unlike regular qualifiers, there can be multiple flags in each url component /fl_1,fl_2/\n        // If the falgs are added to the qualifiers map, only a single flag could exist in a component (it's a map)\n        // So flags are stored separately until the very end because of that reason\n        this.flags = [];\n        this.delimiter = ','; // {qualifier}{delimiter}{qualifier} for example: `${'w_100'}${','}${'c_fill'}`\n        this.actionTag = ''; // A custom name tag to identify this action in the future\n    }\n    prepareQualifiers() { }\n    /**\n     * @description Returns the custom name tag that was given to this action\n     * @return {string}\n     */\n    getActionTag() {\n        return this.actionTag;\n    }\n    /**\n     * @description Sets the custom name tag for this action\n     * @return {this}\n     */\n    setActionTag(tag) {\n        this.actionTag = tag;\n        return this;\n    }\n    /**\n     * @description Calls toString() on all child qualifiers (implicitly by using .join()).\n     * @return {string}\n     */\n    toString() {\n        this.prepareQualifiers();\n        return mapToSortedArray(this.qualifiers, this.flags).join(this.delimiter);\n    }\n    /**\n     * @description Adds the parameter to the action.\n     * @param {SDK.Qualifier} qualifier\n     * @return {this}\n     */\n    addQualifier(qualifier) {\n        // if string, find the key and value\n        if (typeof qualifier === 'string') {\n            const [key, value] = qualifier.toLowerCase().split('_');\n            if (key === 'fl') {\n                // if string qualifier is a flag, store it in the flags arrays\n                this.flags.push(new FlagQualifier(value));\n            }\n            else {\n                // if the string qualifier is not a flag, create a new qualifier from it\n                this.qualifiers.set(key, new Qualifier(key, value));\n            }\n        }\n        else {\n            // if a qualifier object, insert to the qualifiers map\n            this.qualifiers.set(qualifier.key, qualifier);\n        }\n        return this;\n    }\n    /**\n     * @description Adds a flag to the current action.\n     * @param {Qualifiers.Flag} flag\n     * @return {this}\n     */\n    addFlag(flag) {\n        if (typeof flag === 'string') {\n            this.flags.push(new FlagQualifier(flag));\n        }\n        else {\n            if (flag instanceof FlagQualifier) {\n                this.flags.push(flag);\n            }\n        }\n        return this;\n    }\n    addValueToQualifier(qualifierKey, qualifierValue) {\n        this.qualifiers.get(qualifierKey).addValue(qualifierValue);\n        return this;\n    }\n}\nexport { Action };\n"],
  "mappings": "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",
  "names": []
}
