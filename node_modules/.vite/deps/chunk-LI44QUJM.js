import {
  FocusOnValue
} from "./chunk-2XNLFFNL.js";
import {
  noOverflow,
  tiled
} from "./chunk-M5SY7NK2.js";
import {
  Action
} from "./chunk-4UABOL5W.js";
import {
  AutoGravity,
  FocusOnGravity,
  autoGravity
} from "./chunk-LFEWX2TB.js";
import {
  Qualifier
} from "./chunk-UHKTWXPV.js";

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createGravityModel.js
function isIAutoGravityString(gravity) {
  return gravity && `${gravity}`.split(":")[0] === "auto";
}
function isCompassGravity(gravity) {
  const gravityValue = getGravityValue(gravity);
  return ["north", "center", "east", "west", "south", "north_west", "south_east", "south_west", "north_east"].includes(gravityValue);
}
function getGravityValue(gravity) {
  return `${gravity}`.replace("g_", "");
}
function createCompassGravityModel(gravity) {
  return {
    compass: getGravityValue(gravity),
    gravityType: "direction"
  };
}
function isOcrGravity(gravity) {
  return getGravityValue(gravity) === "ocr_text";
}
function createOcrGravityModel() {
  return {
    gravityType: "ocr"
  };
}
function isAutoGravity(gravity) {
  return `${gravity.qualifierValue}`.split(":")[0] === "auto";
}
function createIAutoFocusObject(gravity) {
  const gravityString = gravity.toString();
  const values = gravityString.split("_");
  const result = {
    object: values[0]
  };
  if (values.length > 1) {
    if (values[1] === "avoid") {
      result.avoid = true;
    } else {
      result.weight = +values[1];
    }
  }
  return result;
}
function createAutoGravityModel(gravity) {
  let values;
  const gravityQualifier = gravity === "auto" ? new AutoGravity() : gravity;
  if (`${gravity}`.startsWith("auto:")) {
    values = `${gravity}`.split(":").filter((v) => v !== "auto");
  } else {
    values = gravityQualifier.qualifierValue.values.filter((v) => v !== "auto");
  }
  const autoFocus = values.map(createIAutoFocusObject);
  return {
    gravityType: "auto",
    autoFocus
  };
}
function createFocusOnGravityModel(gravity) {
  const hasAutoGravity = `${gravity}`.split(":").includes("auto");
  const values = gravity.qualifierValue.values;
  const focusOnValues = hasAutoGravity ? values.slice(0, values.length - 1) : values;
  const result = {
    gravityType: "object",
    focusOnObjects: focusOnValues.map((v) => `${v}`)
  };
  if (hasAutoGravity) {
    const autoFocusObjects = values[values.length - 1].values.slice(1);
    const autoGravityInstance = autoGravity().autoFocus(...autoFocusObjects);
    result.fallbackGravity = createAutoGravityModel(autoGravityInstance);
  }
  return result;
}
function createFocusOnGravity(gravity) {
  const values = gravity.split(":");
  const focusOnValues = values.map((g) => new FocusOnValue(g));
  return new FocusOnGravity(focusOnValues);
}
function createGravityModel(gravity) {
  if (isCompassGravity(gravity)) {
    return createCompassGravityModel(gravity);
  }
  if (isOcrGravity(gravity)) {
    return createOcrGravityModel();
  }
  if (isIAutoGravityString(gravity) || isAutoGravity(gravity)) {
    return createAutoGravityModel(gravity);
  }
  return createFocusOnGravityModel(typeof gravity === "string" ? createFocusOnGravity(gravity) : gravity);
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/position/PositionQualifier.js
var PositionQualifier = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
  }
  gravity(gravityQualifier) {
    this.addQualifier(gravityQualifier);
    this._actionModel.gravity = createGravityModel(gravityQualifier);
    return this;
  }
  /**
   * @description Tiles the overlay across your image.
   * <b>Learn more:</b> {@link https://cloudinary.com/documentation/layers#automatic_tiling|Tiling overlay}
   */
  tiled() {
    this.addFlag(tiled());
    this._actionModel.tiled = true;
    return this;
  }
  /**
   * TODO - This should accept a boolean value
   * @description Prevents an image or text overlay from extending a delivered image canvas beyond the dimensions of the base image
   * <b>Learn more:</b> {@link https://cloudinary.com/documentation/transformation_reference#fl_no_overflow|Overflow in overlays}
   */
  allowOverflow(bool = true) {
    if (bool === false) {
      this.addFlag(noOverflow());
    }
    this._actionModel.allowOverflow = bool;
    return this;
  }
  /**
   * @description Set the X Offset
   * @param {number | string} offsetX
   * @return {this}
   */
  offsetX(offsetX) {
    this.addQualifier(new Qualifier("x", offsetX));
    this._actionModel.offsetX = offsetX;
    return this;
  }
  /**
   * @description Set the Y Offset
   * @param {number | string} offsetY
   * @return {this}
   */
  offsetY(offsetY) {
    this.addQualifier(new Qualifier("y", offsetY));
    this._actionModel.offsetY = offsetY;
    return this;
  }
};

export {
  createGravityModel,
  PositionQualifier
};
//# sourceMappingURL=chunk-LI44QUJM.js.map
