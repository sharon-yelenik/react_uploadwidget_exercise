import {
  Action
} from "./chunk-4UABOL5W.js";
import {
  FormatQualifier
} from "./chunk-QVIFFLHX.js";
import {
  TextStyle,
  serializeCloudinaryCharacters,
  solid
} from "./chunk-U7QKKLDD.js";
import {
  Qualifier
} from "./chunk-UHKTWXPV.js";
import {
  QualifierModel
} from "./chunk-EVDDVMJB.js";

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/prepareColor.js
function prepareColor(color) {
  if (color) {
    return color.match(/^#/) ? `rgb:${color.substr(1)}` : color;
  } else {
    return color;
  }
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/BaseSource.js
var BaseSource = class extends QualifierModel {
  /**
   * @description Utility function to encode an asset publicID in an overlay
   * @protected
   * @example
   * encodeAssetPublicID('foo/bar'); // -> foo:bar
   */
  encodeAssetPublicID(publicID) {
    return publicID.replace(/\//g, ":");
  }
  /**
   * @description
   * Apply a transformation on the image source of the layer
   * @param {SDK.ImageTransformation} t An image transformation to apply to the layer
   * @returns {this}
   */
  transformation(t) {
    this._qualifierModel.transformation = t.toJson();
    this._transformation = t;
    return this;
  }
  /**
   * @description Returns the Transformation of the source
   * @return {SDK.Transformation}
   */
  getTransformation() {
    return this._transformation;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/VideoSource.js
var VideoSource = class extends BaseSource {
  constructor(publicID) {
    super();
    this._publicID = publicID;
    this._qualifierModel = {
      publicId: publicID,
      sourceType: "video"
    };
  }
  /**
   * @description
   * Returns the opening string of the layer,
   * This method is used internally within {@link SDK.LayerAction|LayerAction}
   * @returns {string}
   */
  getOpenSourceString(layerType) {
    const encodedPublicID = this.encodeAssetPublicID(this._publicID);
    return `${layerType}_video:${encodedPublicID}`;
  }
  static fromJson(qualifierModel, transformationFromJson) {
    const { publicId, transformation } = qualifierModel;
    const result = new this(publicId);
    if (transformation) {
      result.transformation(transformationFromJson(transformation));
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/ImageSource.js
var ImageSource = class extends BaseSource {
  constructor(publicID) {
    super();
    this._publicID = publicID;
    this._qualifierModel = {
      publicId: publicID,
      sourceType: "image"
    };
  }
  /**
   * @description
   * Returns the opening string of the layer,
   * This method is used internally within {@link SDK.LayerAction|LayerAction}
   * @returns {string}
   */
  getOpenSourceString(layerType) {
    const encodedPublicID = this.encodeAssetPublicID(this._publicID);
    if (this._format) {
      return `${layerType}_${encodedPublicID}.${this._format.toString()}`;
    } else {
      return `${layerType}_${encodedPublicID}`;
    }
  }
  /**
   * @description
   * Apply a format for the image source of the layer
   * @param {FormatQualifier} format A to apply to the layered image, see more {@link Qualifiers.Format|here}
   * @returns {this}
   */
  format(format) {
    this._format = format;
    return this;
  }
  toJson() {
    const result = super.toJson();
    if (result.publicId && this._format) {
      result.publicId = `${result.publicId}.${this._format.toString()}`;
    }
    return result;
  }
  static fromJson(qualifierModel, transformationFromJson) {
    const { publicId, transformation } = qualifierModel;
    const result = new this(publicId);
    if (transformation) {
      result.transformation(transformationFromJson(transformation));
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/base64Encode.js
function base64Encode(input) {
  let encodedResult = "";
  if (typeof window !== "undefined") {
    encodedResult = btoa(encodeURI(decodeURI(input)));
  } else {
    encodedResult = global.Buffer.from(input).toString("base64");
  }
  return encodedResult.replace(/\+/g, "-").replace(/\//g, "_");
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/FetchSource.js
var FetchSource = class extends BaseSource {
  constructor(remoteURL) {
    super();
    this._qualifierModel = {
      sourceType: "fetch",
      url: remoteURL
    };
    this._remoteURL = remoteURL;
  }
  /**
   * @description
   * Returns the opening string of the layer,
   * This method is used internally within {@link SDK.LayerAction|LayerAction}
   * @returns {string}
   */
  getOpenSourceString(layerType) {
    if (this._format) {
      return `${layerType}_fetch:${base64Encode(this._remoteURL)}.${this._format.toString()}`;
    } else {
      return `${layerType}_fetch:${base64Encode(this._remoteURL)}`;
    }
  }
  /**
   * @description
   * Apply a format for the image source of the layer
   * @param {FormatQualifier} format A to apply to the layered image, see more {@link Qualifiers.Format|here}
   * @returns {this}
   */
  format(format) {
    this._qualifierModel.format = format.toString();
    this._format = format;
    return this;
  }
  static fromJson(qualifierModel, transformationFromJson) {
    const { url, transformation, format } = qualifierModel;
    const result = new this(url);
    if (transformation) {
      result.transformation(transformationFromJson(transformation));
    }
    if (format) {
      result.format(new FormatQualifier(format));
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/BaseTextSource.js
var BaseTextSource = class extends BaseSource {
  constructor(text, textStyle) {
    super();
    this.type = "text";
    this.text = text;
    this._textStyle = textStyle;
    this._qualifierModel.sourceType = "text";
    this._qualifierModel.text = text;
    if (textStyle instanceof TextStyle) {
      this._qualifierModel.textStyle = textStyle.toJson();
    }
  }
  encodeText(text) {
    return serializeCloudinaryCharacters(text);
  }
  textColor(color) {
    this._textColor = color;
    this._qualifierModel.textColor = color;
    return this;
  }
  backgroundColor(bgColor) {
    this._backgroundColor = bgColor;
    this._qualifierModel.backgroundColor = bgColor;
    return this;
  }
  textFit(textFit) {
    this._textFit = textFit;
    return this;
  }
  /**
   * @description
   * Returns the opening string of the layer,
   * This method is used internally within {@link SDK.LayerAction|LayerAction}
   * @returns {string}
   */
  getOpenSourceString(layerType) {
    const layerParam = [
      this.type,
      this._textStyle && this._textStyle.toString(),
      this.encodeText(this.text)
    ].filter((a) => a).join(":");
    const tmpAction = new Action();
    tmpAction.addQualifier(new Qualifier(layerType, layerParam));
    this._textColor && tmpAction.addQualifier(new Qualifier("co", prepareColor(this._textColor)));
    this._backgroundColor && tmpAction.addQualifier(new Qualifier("b", prepareColor(this._backgroundColor)));
    this._textFit && tmpAction.addQualifier(this._textFit);
    return tmpAction.toString();
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createTextStyleFromModel.js
function createTextStyleFromModel(textStyleModel) {
  const { fontFamily, fontSize, fontWeight, fontStyle, fontAntialias, fontHinting, textDecoration, textAlignment, stroke, letterSpacing, lineSpacing } = textStyleModel;
  const result = new TextStyle(fontFamily, fontSize);
  if (fontWeight) {
    result.fontWeight(fontWeight);
  }
  if (fontStyle) {
    result.fontStyle(fontStyle);
  }
  if (fontAntialias) {
    result.fontAntialias(fontAntialias);
  }
  if (fontHinting) {
    result.fontHinting(fontHinting);
  }
  if (textDecoration) {
    result.textDecoration(textDecoration);
  }
  if (textAlignment) {
    result.textAlignment(textAlignment);
  }
  if (stroke) {
    result.stroke();
    if (typeof stroke !== "boolean") {
      result.stroke(solid(stroke.width, stroke.color));
    }
  }
  if (letterSpacing) {
    result.letterSpacing(letterSpacing);
  }
  if (lineSpacing) {
    result.lineSpacing(lineSpacing);
  }
  return result;
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/TextSource.js
var TextSource = class extends BaseTextSource {
  constructor(fileName, textStyle) {
    super(fileName, textStyle);
  }
  static fromJson(qualifierModel, transformationFromJson) {
    const { text, textStyle, textColor, backgroundColor, transformation } = qualifierModel;
    const result = new this(text, textStyle ? createTextStyleFromModel(textStyle) : void 0);
    if (transformation) {
      result.transformation(transformationFromJson(transformation));
    }
    if (textColor) {
      result.textColor(textColor);
    }
    if (backgroundColor) {
      result.backgroundColor(backgroundColor);
    }
    return result;
  }
};

export {
  prepareColor,
  base64Encode,
  VideoSource,
  ImageSource,
  BaseTextSource,
  FetchSource,
  TextSource
};
//# sourceMappingURL=chunk-B43TY7UJ.js.map
