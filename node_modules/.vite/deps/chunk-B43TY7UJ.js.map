{
  "version": 3,
  "sources": ["../../@cloudinary/transformation-builder-sdk/internal/utils/prepareColor.js", "../../@cloudinary/transformation-builder-sdk/qualifiers/source/BaseSource.js", "../../@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/VideoSource.js", "../../@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/ImageSource.js", "../../@cloudinary/transformation-builder-sdk/internal/utils/base64Encode.js", "../../@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/FetchSource.js", "../../@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/BaseTextSource.js", "../../@cloudinary/transformation-builder-sdk/internal/models/createTextStyleFromModel.js", "../../@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/TextSource.js"],
  "sourcesContent": ["/**\n * Returns RGB or Color\n * @private\n * @param color\n */\nexport function prepareColor(color) {\n    if (color) {\n        return color.match(/^#/) ? `rgb:${color.substr(1)}` : color;\n    }\n    else {\n        return color;\n    }\n}\n", "import { QualifierModel } from \"../../internal/models/QualifierModel.js\";\n/**\n * @memberOf Qualifiers.Source\n * @extends {QualifierModel}\n * @description An abstract class extended by all Source objects\n */\nclass BaseSource extends QualifierModel {\n    /**\n     * @description Utility function to encode an asset publicID in an overlay\n     * @protected\n     * @example\n     * encodeAssetPublicID('foo/bar'); // -> foo:bar\n     */\n    encodeAssetPublicID(publicID) {\n        return publicID.replace(/\\//g, ':');\n    }\n    /**\n     * @description\n     * Apply a transformation on the image source of the layer\n     * @param {SDK.ImageTransformation} t An image transformation to apply to the layer\n     * @returns {this}\n     */\n    transformation(t) {\n        this._qualifierModel.transformation = t.toJson();\n        this._transformation = t;\n        return this;\n    }\n    /**\n     * @description Returns the Transformation of the source\n     * @return {SDK.Transformation}\n     */\n    getTransformation() {\n        return this._transformation;\n    }\n}\nexport { BaseSource };\n", "import { BaseSource } from \"../BaseSource.js\";\n/**\n * @memberOf Qualifiers.Source\n * @extends {Qualifiers.Source.BaseSource}\n * @description Defines how to manipulate a video layer, is an instance of a {@link VideoTransformation|VideoTransformation}\n * <div class=\"panel panel-primary\">\n *   <div class=\"panel-heading\">Notice</div>\n *   <div class=\"panel-body\">\n *     This class is used as a Qualifier for the asset.overlay() and asset.underlay() methods.</br>\n *     You can find regular images and videos transformations below:\n *   </div>\n *   <ul>\n *     <li>{@link SDK.ImageTransformation| Image Transformations}</li>\n *     <li>{@link SDK.VideoTransformation| Video Transformations}\n *   </ul>\n * </div>\n */\nclass VideoSource extends BaseSource {\n    constructor(publicID) {\n        super();\n        this._publicID = publicID;\n        this._qualifierModel = {\n            publicId: publicID,\n            sourceType: 'video'\n        };\n    }\n    /**\n     * @description\n     * Returns the opening string of the layer,\n     * This method is used internally within {@link SDK.LayerAction|LayerAction}\n     * @returns {string}\n     */\n    getOpenSourceString(layerType) {\n        const encodedPublicID = this.encodeAssetPublicID(this._publicID);\n        return `${layerType}_video:${encodedPublicID}`;\n    }\n    static fromJson(qualifierModel, transformationFromJson) {\n        const { publicId, transformation } = qualifierModel;\n        // We are using this() to allow inheriting classes to use super.fromJson.apply(this, [qualifierModel])\n        // This allows the inheriting classes to determine the class to be created\n        // @ts-ignore\n        const result = new this(publicId);\n        if (transformation) {\n            result.transformation(transformationFromJson(transformation));\n        }\n        return result;\n    }\n}\nexport { VideoSource };\n", "import { BaseSource } from \"../BaseSource.js\";\n/**\n * @memberOf Qualifiers.Source\n * @extends {Qualifiers.Source.BaseSource}\n * @description Defines how to manipulate an image layer\n * <div class=\"panel panel-warning\">\n *   <div class=\"panel-heading\">Notice</div>\n *   <div class=\"panel-body\">\n *     This class is used as a Qualifier for the asset.overlay() and asset.underlay() methods.</br>\n *     You can find regular images and videos transformations below:\n *   </div>\n *   <ul>\n *     <li>{@link SDK.ImageTransformation| Image Transformations}</li>\n *     <li>{@link SDK.VideoTransformation| Video Transformations}\n *   </ul>\n * </div>\n */\nclass ImageSource extends BaseSource {\n    constructor(publicID) {\n        super();\n        this._publicID = publicID;\n        this._qualifierModel = {\n            publicId: publicID,\n            sourceType: 'image'\n        };\n    }\n    /**\n     * @description\n     * Returns the opening string of the layer,\n     * This method is used internally within {@link SDK.LayerAction|LayerAction}\n     * @returns {string}\n     */\n    getOpenSourceString(layerType) {\n        const encodedPublicID = this.encodeAssetPublicID(this._publicID);\n        if (this._format) {\n            return `${layerType}_${encodedPublicID}.${this._format.toString()}`;\n        }\n        else {\n            return `${layerType}_${encodedPublicID}`;\n        }\n    }\n    /**\n     * @description\n     * Apply a format for the image source of the layer\n     * @param {FormatQualifier} format A to apply to the layered image, see more {@link Qualifiers.Format|here}\n     * @returns {this}\n     */\n    format(format) {\n        this._format = format;\n        return this;\n    }\n    toJson() {\n        const result = super.toJson();\n        if (result.publicId && this._format) {\n            result.publicId = `${result.publicId}.${this._format.toString()}`;\n        }\n        return result;\n    }\n    static fromJson(qualifierModel, transformationFromJson) {\n        const { publicId, transformation } = qualifierModel;\n        // We are using this() to allow inheriting classes to use super.fromJson.apply(this, [qualifierModel])\n        // This allows the inheriting classes to determine the class to be created\n        // @ts-ignore\n        const result = new this(publicId);\n        if (transformation) {\n            result.transformation(transformationFromJson(transformation));\n        }\n        return result;\n    }\n}\nexport { ImageSource };\n", "/**\n *\n * @private\n * @description An isomorphic Base64 function, provides browser and server support.\n * @param {string} input - A string to encode with base64\n */\nfunction base64Encode(input) {\n    // Browser\n    let encodedResult = '';\n    if (typeof window !== 'undefined') {\n        // encodeURI the input to support unicode characters\n        // Since the URI might be encoded already, we try to decode it once before\n        encodedResult = btoa(encodeURI(decodeURI(input)));\n    }\n    else {\n        // NodeJS support\n        encodedResult = global.Buffer.from(input).toString('base64');\n    }\n    return encodedResult\n        .replace(/\\+/g, '-') // Convert '+' to '-'\n        .replace(/\\//g, '_'); // Convert '/' to '_';\n}\nexport { base64Encode };\n", "import { BaseSource } from \"../BaseSource.js\";\nimport { FormatQualifier } from \"../../format/FormatQualifier.js\";\nimport { base64Encode } from \"../../../internal/utils/base64Encode.js\";\n/**\n * @memberOf Qualifiers.Source\n * @extends {Qualifiers.Source.BaseSource}\n * @description Defines how to manipulate a Fetch layer\n * <div class=\"panel panel-warning\">\n *   <div class=\"panel-heading\">Notice</div>\n *   <div class=\"panel-body\">\n *     This class is used as a Qualifier for the asset.overlay() and asset.underlay() methods.</br>\n *     You can find regular images and videos transformations below:\n *   </div>\n  *   <ul>\n *     <li>{@link SDK.ImageTransformation| Image Transformations}</li>\n *     <li>{@link SDK.VideoTransformation| Video Transformations}</li>\n *   </ul>\n * </div>\n *\n * {@link https://cloudinary.com/documentation/fetch_remote_images|Learn more about fetching from a remote URL}\n */\nclass FetchSource extends BaseSource {\n    constructor(remoteURL) {\n        super();\n        this._qualifierModel = {\n            sourceType: 'fetch',\n            url: remoteURL\n        };\n        this._remoteURL = remoteURL;\n    }\n    /**\n     * @description\n     * Returns the opening string of the layer,\n     * This method is used internally within {@link SDK.LayerAction|LayerAction}\n     * @returns {string}\n     */\n    getOpenSourceString(layerType) {\n        if (this._format) {\n            return `${layerType}_fetch:${base64Encode(this._remoteURL)}.${this._format.toString()}`;\n        }\n        else {\n            return `${layerType}_fetch:${base64Encode(this._remoteURL)}`;\n        }\n    }\n    /**\n     * @description\n     * Apply a format for the image source of the layer\n     * @param {FormatQualifier} format A to apply to the layered image, see more {@link Qualifiers.Format|here}\n     * @returns {this}\n     */\n    format(format) {\n        this._qualifierModel.format = format.toString();\n        this._format = format;\n        return this;\n    }\n    static fromJson(qualifierModel, transformationFromJson) {\n        const { url, transformation, format } = qualifierModel;\n        // We are using this() to allow inheriting classes to use super.fromJson.apply(this, [qualifierModel])\n        // This allows the inheriting classes to determine the class to be created\n        const result = new this(url);\n        if (transformation) {\n            result.transformation(transformationFromJson(transformation));\n        }\n        if (format) {\n            result.format(new FormatQualifier(format));\n        }\n        return result;\n    }\n}\nexport { FetchSource };\n", "import { BaseSource } from \"../BaseSource.js\";\nimport { TextStyle } from \"../../textStyle.js\";\nimport { serializeCloudinaryCharacters } from \"../../../internal/utils/serializeCloudinaryCharacters.js\";\nimport { Action } from \"../../../internal/Action.js\";\nimport { Qualifier } from \"../../../internal/qualifier/Qualifier.js\";\nimport { prepareColor } from \"../../../internal/utils/prepareColor.js\";\n/**\n * @memberOf Qualifiers.Source\n * @extends {Qualifiers.Source.BaseSource}\n * @description Defines the common interface for all text-based sources\n */\nclass BaseTextSource extends BaseSource {\n    constructor(text, textStyle) {\n        super();\n        this.type = 'text';\n        this.text = text;\n        this._textStyle = textStyle;\n        this._qualifierModel.sourceType = 'text';\n        this._qualifierModel.text = text;\n        if (textStyle instanceof TextStyle) {\n            this._qualifierModel.textStyle = textStyle.toJson();\n        }\n    }\n    encodeText(text) {\n        return serializeCloudinaryCharacters(text);\n    }\n    textColor(color) {\n        this._textColor = color;\n        this._qualifierModel.textColor = color;\n        return this;\n    }\n    backgroundColor(bgColor) {\n        this._backgroundColor = bgColor;\n        this._qualifierModel.backgroundColor = bgColor;\n        return this;\n    }\n    textFit(textFit) {\n        this._textFit = textFit;\n        return this;\n    }\n    /**\n     * @description\n     * Returns the opening string of the layer,\n     * This method is used internally within {@link SDK.LayerAction|LayerAction}\n     * @returns {string}\n     */\n    getOpenSourceString(layerType) {\n        const layerParam = [\n            this.type,\n            this._textStyle && this._textStyle.toString(),\n            this.encodeText(this.text)\n        ].filter((a) => a).join(':');\n        const tmpAction = new Action();\n        tmpAction.addQualifier(new Qualifier(layerType, layerParam));\n        this._textColor && tmpAction.addQualifier(new Qualifier('co', prepareColor(this._textColor)));\n        this._backgroundColor && tmpAction.addQualifier(new Qualifier('b', prepareColor(this._backgroundColor)));\n        this._textFit && tmpAction.addQualifier(this._textFit);\n        return tmpAction.toString();\n    }\n}\nexport { BaseTextSource };\n", "import { TextStyle } from \"../../qualifiers/textStyle.js\";\nimport { solid } from \"../../qualifiers/textStroke.js\";\n/**\n * Create TextStyle from ITextStyleModel\n * @param textStyleModel\n */\nexport function createTextStyleFromModel(textStyleModel) {\n    const { fontFamily, fontSize, fontWeight, fontStyle, fontAntialias, fontHinting, textDecoration, textAlignment, stroke, letterSpacing, lineSpacing, } = textStyleModel;\n    const result = new TextStyle(fontFamily, fontSize);\n    if (fontWeight) {\n        result.fontWeight(fontWeight);\n    }\n    if (fontStyle) {\n        result.fontStyle(fontStyle);\n    }\n    if (fontAntialias) {\n        result.fontAntialias(fontAntialias);\n    }\n    if (fontHinting) {\n        result.fontHinting(fontHinting);\n    }\n    if (textDecoration) {\n        result.textDecoration(textDecoration);\n    }\n    if (textAlignment) {\n        result.textAlignment(textAlignment);\n    }\n    if (stroke) {\n        result.stroke();\n        if (typeof stroke !== \"boolean\") {\n            result.stroke(solid(stroke.width, stroke.color));\n        }\n    }\n    if (letterSpacing) {\n        result.letterSpacing(letterSpacing);\n    }\n    if (lineSpacing) {\n        result.lineSpacing(lineSpacing);\n    }\n    return result;\n}\n", "import { BaseTextSource } from \"./BaseTextSource.js\";\nimport { createTextStyleFromModel } from \"../../../internal/models/createTextStyleFromModel.js\";\n/**\n * @memberOf Qualifiers.Source\n * @extends {Qualifiers.Source.BaseTextSource}\n * @description Defines how to manipulate a text layer\n */\nclass TextSource extends BaseTextSource {\n    constructor(fileName, textStyle) {\n        /* istanbul ignore next */\n        super(fileName, textStyle);\n    }\n    static fromJson(qualifierModel, transformationFromJson) {\n        const { text, textStyle, textColor, backgroundColor, transformation } = qualifierModel;\n        // We are using this() to allow inheriting classes to use super.fromJson.apply(this, [qualifierModel])\n        // This allows the inheriting classes to determine the class to be created\n        const result = new this(text, textStyle ? createTextStyleFromModel(textStyle) : undefined);\n        if (transformation) {\n            result.transformation(transformationFromJson(transformation));\n        }\n        if (textColor) {\n            result.textColor(textColor);\n        }\n        if (backgroundColor) {\n            result.backgroundColor(backgroundColor);\n        }\n        return result;\n    }\n}\nexport { TextSource };\n"],
  "mappings": "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",
  "names": []
}
