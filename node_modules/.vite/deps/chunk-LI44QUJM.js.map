{
  "version": 3,
  "sources": ["../../@cloudinary/transformation-builder-sdk/internal/models/createGravityModel.js", "../../@cloudinary/transformation-builder-sdk/qualifiers/position/PositionQualifier.js"],
  "sourcesContent": ["import { AutoGravity } from \"../../qualifiers/gravity/autoGravity/AutoGravity.js\";\nimport { FocusOnGravity } from \"../../qualifiers/gravity/focusOnGravity/FocusOnGravity.js\";\nimport { autoGravity } from \"../../qualifiers/gravity.js\";\nimport { FocusOnValue } from \"../../qualifiers/focusOn.js\";\n/**\n * true if gravity starts with 'auto' or 'auto:'\n * @param gravity\n */\nfunction isIAutoGravityString(gravity) {\n    return gravity && `${gravity}`.split(':')[0] === 'auto';\n}\n/**\n * Validate that given val is an ICompassGravity\n * @param gravity\n */\nfunction isCompassGravity(gravity) {\n    //const gravityString = `${(typeof gravity === \"string\" ? gravity : gravity.qualifierValue)}`;\n    const gravityValue = getGravityValue(gravity);\n    return ['north', 'center', 'east', 'west', 'south', 'north_west', 'south_east', 'south_west', 'north_east'].includes(gravityValue);\n}\n/**\n * Get the value of given gravity\n * @param gravity\n */\nfunction getGravityValue(gravity) {\n    return `${gravity}`.replace('g_', '');\n}\n/**\n * Creates a compassGravity model\n * @param gravity\n */\nfunction createCompassGravityModel(gravity) {\n    return {\n        compass: getGravityValue(gravity),\n        gravityType: 'direction'\n    };\n}\n/**\n * Validate that given gravity is an instance of ocr gravity\n * @param gravity\n */\nfunction isOcrGravity(gravity) {\n    return getGravityValue(gravity) === 'ocr_text';\n}\n/**\n * Creates an ocr gravity model\n */\nfunction createOcrGravityModel() {\n    return {\n        gravityType: 'ocr'\n    };\n}\n/**\n * Validate that given gravity is an instance of AutoGravity\n * @param gravity\n */\nfunction isAutoGravity(gravity) {\n    return `${gravity.qualifierValue}`.split(':')[0] === 'auto';\n}\n/**\n * Create an instance of IAutoGravityObjectModel\n * @param gravity\n */\nfunction createIAutoFocusObject(gravity) {\n    const gravityString = gravity.toString();\n    const values = gravityString.split('_');\n    const result = {\n        object: values[0]\n    };\n    if (values.length > 1) {\n        if (values[1] === 'avoid') {\n            result.avoid = true;\n        }\n        else {\n            result.weight = +values[1];\n        }\n    }\n    return result;\n}\n/**\n * Creates an auto gravity model from given AutoGravity\n * @param gravity\n */\nfunction createAutoGravityModel(gravity) {\n    let values;\n    const gravityQualifier = gravity === 'auto' ? new AutoGravity() : gravity;\n    if (`${gravity}`.startsWith('auto:')) {\n        values = `${gravity}`.split(':').filter((v) => v !== 'auto');\n    }\n    else {\n        values = gravityQualifier.qualifierValue.values.filter((v) => v !== 'auto');\n    }\n    const autoFocus = values.map(createIAutoFocusObject);\n    return {\n        gravityType: 'auto',\n        autoFocus\n    };\n}\n/**\n * Create IFocusOnGravityModel from FocusOnGravity\n * @param gravity\n */\nfunction createFocusOnGravityModel(gravity) {\n    const hasAutoGravity = `${gravity}`.split(':').includes('auto');\n    const values = gravity.qualifierValue.values;\n    const focusOnValues = hasAutoGravity ? values.slice(0, values.length - 1) : values;\n    const result = {\n        gravityType: 'object',\n        focusOnObjects: focusOnValues.map((v) => `${v}`)\n    };\n    if (hasAutoGravity) {\n        // Remove the first 'auto' value by slicing it, because it's added by autoGravity()\n        const autoFocusObjects = values[values.length - 1].values.slice(1);\n        const autoGravityInstance = autoGravity().autoFocus(...autoFocusObjects);\n        result.fallbackGravity = createAutoGravityModel(autoGravityInstance);\n    }\n    return result;\n}\n/**\n * Creates a FocusOnGravity from given string\n * @param gravity\n */\nfunction createFocusOnGravity(gravity) {\n    const values = gravity.split(':');\n    const focusOnValues = values.map((g) => new FocusOnValue(g));\n    return new FocusOnGravity(focusOnValues);\n}\n/**\n * Create a model of given gravity\n * @param gravity\n */\nexport function createGravityModel(gravity) {\n    if (isCompassGravity(gravity)) {\n        return createCompassGravityModel(gravity);\n    }\n    if (isOcrGravity(gravity)) {\n        return createOcrGravityModel();\n    }\n    if (isIAutoGravityString(gravity) || isAutoGravity(gravity)) {\n        return createAutoGravityModel(gravity);\n    }\n    return createFocusOnGravityModel(typeof gravity === 'string' ? createFocusOnGravity(gravity) : gravity);\n}\n", "import { Action } from \"../../internal/Action.js\";\nimport { Qualifier } from \"../../internal/qualifier/Qualifier.js\";\nimport { tiled } from \"../flag.js\";\nimport { noOverflow } from \"../flag.js\";\nimport { createGravityModel } from \"../../internal/models/createGravityModel.js\";\n/**\n * @description\n * Defines the position of a layer: overlay or underlay.</br>\n * Even though Position is technically an action qualifier, it implements exactly the same functionality as an action.</br>\n * This is true because Position is compounded of multiple qualifiers</br>\n *\n * <b>Learn more:</b> {@link https://cloudinary.com/documentation/layers|Applying overlays to images} | {@link https://cloudinary.com/documentation/video_layers|Applying overlays to videos}\n *\n * @extends {SDK.Actions}\n */\nclass PositionQualifier extends Action {\n    constructor() {\n        super();\n        this._actionModel = {};\n    }\n    gravity(gravityQualifier) {\n        this.addQualifier(gravityQualifier);\n        this._actionModel.gravity = createGravityModel(gravityQualifier);\n        return this;\n    }\n    /**\n     * @description Tiles the overlay across your image.\n     * <b>Learn more:</b> {@link https://cloudinary.com/documentation/layers#automatic_tiling|Tiling overlay}\n     */\n    tiled() {\n        this.addFlag(tiled());\n        this._actionModel.tiled = true;\n        return this;\n    }\n    /**\n     * TODO - This should accept a boolean value\n     * @description Prevents an image or text overlay from extending a delivered image canvas beyond the dimensions of the base image\n     * <b>Learn more:</b> {@link https://cloudinary.com/documentation/transformation_reference#fl_no_overflow|Overflow in overlays}\n     */\n    allowOverflow(bool = true) {\n        if (bool === false) {\n            this.addFlag(noOverflow());\n        }\n        this._actionModel.allowOverflow = bool;\n        return this;\n    }\n    /**\n     * @description Set the X Offset\n     * @param {number | string} offsetX\n     * @return {this}\n     */\n    offsetX(offsetX) {\n        this.addQualifier(new Qualifier('x', offsetX));\n        this._actionModel.offsetX = offsetX;\n        return this;\n    }\n    /**\n     * @description Set the Y Offset\n     * @param {number | string} offsetY\n     * @return {this}\n     */\n    offsetY(offsetY) {\n        this.addQualifier(new Qualifier('y', offsetY));\n        this._actionModel.offsetY = offsetY;\n        return this;\n    }\n}\nexport { PositionQualifier };\n"],
  "mappings": "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",
  "names": []
}
